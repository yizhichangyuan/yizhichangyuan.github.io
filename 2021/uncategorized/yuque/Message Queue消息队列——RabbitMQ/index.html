<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>Message Queue消息队列——RabbitMQ | 一止长渊的博客</title>

    <meta name="description" content="&lt;p&gt;和队列 Queue 类似，不过消息队列是在分布式情况下，每个服务从一个消息队列中取出东西。消息保存到消息队列中，别的服务从消息中间件中取消息。&lt;/p&gt;
&lt;h3 id=&#34;一、应用场景&#34;&gt;&lt;a href=&#34;#一、应用场景&#34; class=&#34;headerlink&#34; title=&#34;一、应用场景&#34;&gt;&lt;/a&gt;一、应用场景&lt;/h3&gt;&lt;p&gt;异步、削峰、解耦&lt;/p&gt;
&lt;h4 id=&#34;1-异步&#34;&gt;&lt;a href=&#34;#1-异步&#34; class=&#34;headerlink&#34; title=&#34;1.异步&#34;&gt;&lt;/a&gt;1.异步&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2021/png/2648023/1621338379093-fd517de9-ba79-42d8-9033-e7f33b406df1.png#align=left&amp;display=inline&amp;height=421&amp;margin=%5Bobject%20Object%5D&amp;name=%E6%88%AA%E5%B1%8F2021-05-18%2019.45.28.png&amp;originHeight=1066&amp;originWidth=1772&amp;size=603370&amp;status=done&amp;style=none&amp;width=700&#34; alt=&#34;截屏2021-05-18 19.45.28.png&#34;&gt;&lt;br&gt;&lt;strong&gt;例如用户注册为例&lt;/strong&gt;&lt;br&gt;图 1：需要将用户信息写入到数据库中，然后发送注册邮件和注册短信，如果按照图 1 的方式顺序进行就会响应达到 150ms；&lt;br&gt;图 2：如果使用 CompletableFuture 进行异步编排，将发送注册邮件和发送注册信息进行并行处理，等待两者都完成就进行返回，则响应可以缩减到 100ms&lt;br&gt;图 3：其实我们并不关心发送注册邮件和短信是否成功，即使有时候是不成功的状态也是可以理解的，只要用户重复几次就行。只要将注册信息写入数据库，然后将消息写入到消息队列中，就立即返回，延迟就只需要 55ms，发送注册邮件和发送注册短信会由其他微服务从消息队列中取出消息进行处理，这样就可以将延迟进行进一步缩短。&lt;/p&gt;
&lt;h4 id=&#34;2-解耦&#34;&gt;&lt;a href=&#34;#2-解耦&#34; class=&#34;headerlink&#34; title=&#34;2.解耦&#34;&gt;&lt;/a&gt;2.解耦&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2021/png/2648023/1621339118945-ef11d72e-bd9e-4778-831e-ab2af9656f81.png#align=left&amp;display=inline&amp;height=550&amp;margin=%5Bobject%20Object%5D&amp;name=%E6%88%AA%E5%B1%8F2021-05-18%2019.58.18.png&amp;originHeight=888&amp;originWidth=808&amp;size=261107&amp;status=done&amp;style=none&amp;width=500&#34; alt=&#34;截屏2021-05-18 19.58.18.png&#34;&gt;&lt;br&gt;当服务之间进行相互调用时，例如订单服务下单时需要调用库存服务进行出库操作，但是库存系统经常进行升级，导致接口参数经常发生变化，如果是使用 Feign 进行调用，当库存系统进行升级了，订单系统中的 Feign 接口就会发生变动。如果使用消息队列就可以进行解耦，当订单系统下订单后向消息队列中写入消息：某某下了一个订单，购置商品 xxx 几件，然后库存系统从消息队列中取出消息即可，这样就进行了解耦。&lt;/p&gt;">
    <meta name="keywords" content="JAVA 后端 Spring">

    

    <meta property="og:locale" content="en" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content= "Message Queue消息队列——RabbitMQ | 一止长渊的博客"  />
    <meta property="og:description" content= "&lt;p&gt;和队列 Queue 类似，不过消息队列是在分布式情况下，每个服务从一个消息队列中取出东西。消息保存到消息队列中，别的服务从消息中间件中取消息。&lt;/p&gt;
&lt;h3 id=&#34;一、应用场景&#34;&gt;&lt;a href=&#34;#一、应用场景&#34; class=&#34;headerlink&#34; title=&#34;一、应用场景&#34;&gt;&lt;/a&gt;一、应用场景&lt;/h3&gt;&lt;p&gt;异步、削峰、解耦&lt;/p&gt;
&lt;h4 id=&#34;1-异步&#34;&gt;&lt;a href=&#34;#1-异步&#34; class=&#34;headerlink&#34; title=&#34;1.异步&#34;&gt;&lt;/a&gt;1.异步&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2021/png/2648023/1621338379093-fd517de9-ba79-42d8-9033-e7f33b406df1.png#align=left&amp;display=inline&amp;height=421&amp;margin=%5Bobject%20Object%5D&amp;name=%E6%88%AA%E5%B1%8F2021-05-18%2019.45.28.png&amp;originHeight=1066&amp;originWidth=1772&amp;size=603370&amp;status=done&amp;style=none&amp;width=700&#34; alt=&#34;截屏2021-05-18 19.45.28.png&#34;&gt;&lt;br&gt;&lt;strong&gt;例如用户注册为例&lt;/strong&gt;&lt;br&gt;图 1：需要将用户信息写入到数据库中，然后发送注册邮件和注册短信，如果按照图 1 的方式顺序进行就会响应达到 150ms；&lt;br&gt;图 2：如果使用 CompletableFuture 进行异步编排，将发送注册邮件和发送注册信息进行并行处理，等待两者都完成就进行返回，则响应可以缩减到 100ms&lt;br&gt;图 3：其实我们并不关心发送注册邮件和短信是否成功，即使有时候是不成功的状态也是可以理解的，只要用户重复几次就行。只要将注册信息写入数据库，然后将消息写入到消息队列中，就立即返回，延迟就只需要 55ms，发送注册邮件和发送注册短信会由其他微服务从消息队列中取出消息进行处理，这样就可以将延迟进行进一步缩短。&lt;/p&gt;
&lt;h4 id=&#34;2-解耦&#34;&gt;&lt;a href=&#34;#2-解耦&#34; class=&#34;headerlink&#34; title=&#34;2.解耦&#34;&gt;&lt;/a&gt;2.解耦&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2021/png/2648023/1621339118945-ef11d72e-bd9e-4778-831e-ab2af9656f81.png#align=left&amp;display=inline&amp;height=550&amp;margin=%5Bobject%20Object%5D&amp;name=%E6%88%AA%E5%B1%8F2021-05-18%2019.58.18.png&amp;originHeight=888&amp;originWidth=808&amp;size=261107&amp;status=done&amp;style=none&amp;width=500&#34; alt=&#34;截屏2021-05-18 19.58.18.png&#34;&gt;&lt;br&gt;当服务之间进行相互调用时，例如订单服务下单时需要调用库存服务进行出库操作，但是库存系统经常进行升级，导致接口参数经常发生变化，如果是使用 Feign 进行调用，当库存系统进行升级了，订单系统中的 Feign 接口就会发生变动。如果使用消息队列就可以进行解耦，当订单系统下订单后向消息队列中写入消息：某某下了一个订单，购置商品 xxx 几件，然后库存系统从消息队列中取出消息即可，这样就进行了解耦。&lt;/p&gt;" />
    <meta property="og:url" content="http://example.com/2021/uncategorized/yuque/Message%20Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/index.html" />
    <meta property="og:site_name" content="" />
    <meta property="article:author" content="一止长渊" />
    <meta property="article:publisher" content="" />
    <meta property="og:description" content="&lt;p&gt;和队列 Queue 类似，不过消息队列是在分布式情况下，每个服务从一个消息队列中取出东西。消息保存到消息队列中，别的服务从消息中间件中取消息。&lt;/p&gt;
&lt;h3 id=&#34;一、应用场景&#34;&gt;&lt;a href=&#34;#一、应用场景&#34; class=&#34;headerlink&#34; title=&#34;一、应用场景&#34;&gt;&lt;/a&gt;一、应用场景&lt;/h3&gt;&lt;p&gt;异步、削峰、解耦&lt;/p&gt;
&lt;h4 id=&#34;1-异步&#34;&gt;&lt;a href=&#34;#1-异步&#34; class=&#34;headerlink&#34; title=&#34;1.异步&#34;&gt;&lt;/a&gt;1.异步&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2021/png/2648023/1621338379093-fd517de9-ba79-42d8-9033-e7f33b406df1.png#align=left&amp;display=inline&amp;height=421&amp;margin=%5Bobject%20Object%5D&amp;name=%E6%88%AA%E5%B1%8F2021-05-18%2019.45.28.png&amp;originHeight=1066&amp;originWidth=1772&amp;size=603370&amp;status=done&amp;style=none&amp;width=700&#34; alt=&#34;截屏2021-05-18 19.45.28.png&#34;&gt;&lt;br&gt;&lt;strong&gt;例如用户注册为例&lt;/strong&gt;&lt;br&gt;图 1：需要将用户信息写入到数据库中，然后发送注册邮件和注册短信，如果按照图 1 的方式顺序进行就会响应达到 150ms；&lt;br&gt;图 2：如果使用 CompletableFuture 进行异步编排，将发送注册邮件和发送注册信息进行并行处理，等待两者都完成就进行返回，则响应可以缩减到 100ms&lt;br&gt;图 3：其实我们并不关心发送注册邮件和短信是否成功，即使有时候是不成功的状态也是可以理解的，只要用户重复几次就行。只要将注册信息写入数据库，然后将消息写入到消息队列中，就立即返回，延迟就只需要 55ms，发送注册邮件和发送注册短信会由其他微服务从消息队列中取出消息进行处理，这样就可以将延迟进行进一步缩短。&lt;/p&gt;
&lt;h4 id=&#34;2-解耦&#34;&gt;&lt;a href=&#34;#2-解耦&#34; class=&#34;headerlink&#34; title=&#34;2.解耦&#34;&gt;&lt;/a&gt;2.解耦&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2021/png/2648023/1621339118945-ef11d72e-bd9e-4778-831e-ab2af9656f81.png#align=left&amp;display=inline&amp;height=550&amp;margin=%5Bobject%20Object%5D&amp;name=%E6%88%AA%E5%B1%8F2021-05-18%2019.58.18.png&amp;originHeight=888&amp;originWidth=808&amp;size=261107&amp;status=done&amp;style=none&amp;width=500&#34; alt=&#34;截屏2021-05-18 19.58.18.png&#34;&gt;&lt;br&gt;当服务之间进行相互调用时，例如订单服务下单时需要调用库存服务进行出库操作，但是库存系统经常进行升级，导致接口参数经常发生变化，如果是使用 Feign 进行调用，当库存系统进行升级了，订单系统中的 Feign 接口就会发生变动。如果使用消息队列就可以进行解耦，当订单系统下订单后向消息队列中写入消息：某某下了一个订单，购置商品 xxx 几件，然后库存系统从消息队列中取出消息即可，这样就进行了解耦。&lt;/p&gt;" />
    <meta name="twitter:title" content="Message Queue消息队列——RabbitMQ | 一止长渊的博客"/>
    <meta name="twitter:description" content="&lt;p&gt;和队列 Queue 类似，不过消息队列是在分布式情况下，每个服务从一个消息队列中取出东西。消息保存到消息队列中，别的服务从消息中间件中取消息。&lt;/p&gt;
&lt;h3 id=&#34;一、应用场景&#34;&gt;&lt;a href=&#34;#一、应用场景&#34; class=&#34;headerlink&#34; title=&#34;一、应用场景&#34;&gt;&lt;/a&gt;一、应用场景&lt;/h3&gt;&lt;p&gt;异步、削峰、解耦&lt;/p&gt;
&lt;h4 id=&#34;1-异步&#34;&gt;&lt;a href=&#34;#1-异步&#34; class=&#34;headerlink&#34; title=&#34;1.异步&#34;&gt;&lt;/a&gt;1.异步&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2021/png/2648023/1621338379093-fd517de9-ba79-42d8-9033-e7f33b406df1.png#align=left&amp;display=inline&amp;height=421&amp;margin=%5Bobject%20Object%5D&amp;name=%E6%88%AA%E5%B1%8F2021-05-18%2019.45.28.png&amp;originHeight=1066&amp;originWidth=1772&amp;size=603370&amp;status=done&amp;style=none&amp;width=700&#34; alt=&#34;截屏2021-05-18 19.45.28.png&#34;&gt;&lt;br&gt;&lt;strong&gt;例如用户注册为例&lt;/strong&gt;&lt;br&gt;图 1：需要将用户信息写入到数据库中，然后发送注册邮件和注册短信，如果按照图 1 的方式顺序进行就会响应达到 150ms；&lt;br&gt;图 2：如果使用 CompletableFuture 进行异步编排，将发送注册邮件和发送注册信息进行并行处理，等待两者都完成就进行返回，则响应可以缩减到 100ms&lt;br&gt;图 3：其实我们并不关心发送注册邮件和短信是否成功，即使有时候是不成功的状态也是可以理解的，只要用户重复几次就行。只要将注册信息写入数据库，然后将消息写入到消息队列中，就立即返回，延迟就只需要 55ms，发送注册邮件和发送注册短信会由其他微服务从消息队列中取出消息进行处理，这样就可以将延迟进行进一步缩短。&lt;/p&gt;
&lt;h4 id=&#34;2-解耦&#34;&gt;&lt;a href=&#34;#2-解耦&#34; class=&#34;headerlink&#34; title=&#34;2.解耦&#34;&gt;&lt;/a&gt;2.解耦&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2021/png/2648023/1621339118945-ef11d72e-bd9e-4778-831e-ab2af9656f81.png#align=left&amp;display=inline&amp;height=550&amp;margin=%5Bobject%20Object%5D&amp;name=%E6%88%AA%E5%B1%8F2021-05-18%2019.58.18.png&amp;originHeight=888&amp;originWidth=808&amp;size=261107&amp;status=done&amp;style=none&amp;width=500&#34; alt=&#34;截屏2021-05-18 19.58.18.png&#34;&gt;&lt;br&gt;当服务之间进行相互调用时，例如订单服务下单时需要调用库存服务进行出库操作，但是库存系统经常进行升级，导致接口参数经常发生变化，如果是使用 Feign 进行调用，当库存系统进行升级了，订单系统中的 Feign 接口就会发生变动。如果使用消息队列就可以进行解耦，当订单系统下订单后向消息队列中写入消息：某某下了一个订单，购置商品 xxx 几件，然后库存系统从消息队列中取出消息即可，这样就进行了解耦。&lt;/p&gt;"/>
    <script type="application/ld+json">
        {
            "description": "&lt;p&gt;和队列 Queue 类似，不过消息队列是在分布式情况下，每个服务从一个消息队列中取出东西。消息保存到消息队列中，别的服务从消息中间件中取消息。&lt;/p&gt;
&lt;h3 id=&#34;一、应用场景&#34;&gt;&lt;a href=&#34;#一、应用场景&#34; class=&#34;headerlink&#34; title=&#34;一、应用场景&#34;&gt;&lt;/a&gt;一、应用场景&lt;/h3&gt;&lt;p&gt;异步、削峰、解耦&lt;/p&gt;
&lt;h4 id=&#34;1-异步&#34;&gt;&lt;a href=&#34;#1-异步&#34; class=&#34;headerlink&#34; title=&#34;1.异步&#34;&gt;&lt;/a&gt;1.异步&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2021/png/2648023/1621338379093-fd517de9-ba79-42d8-9033-e7f33b406df1.png#align=left&amp;display=inline&amp;height=421&amp;margin=%5Bobject%20Object%5D&amp;name=%E6%88%AA%E5%B1%8F2021-05-18%2019.45.28.png&amp;originHeight=1066&amp;originWidth=1772&amp;size=603370&amp;status=done&amp;style=none&amp;width=700&#34; alt=&#34;截屏2021-05-18 19.45.28.png&#34;&gt;&lt;br&gt;&lt;strong&gt;例如用户注册为例&lt;/strong&gt;&lt;br&gt;图 1：需要将用户信息写入到数据库中，然后发送注册邮件和注册短信，如果按照图 1 的方式顺序进行就会响应达到 150ms；&lt;br&gt;图 2：如果使用 CompletableFuture 进行异步编排，将发送注册邮件和发送注册信息进行并行处理，等待两者都完成就进行返回，则响应可以缩减到 100ms&lt;br&gt;图 3：其实我们并不关心发送注册邮件和短信是否成功，即使有时候是不成功的状态也是可以理解的，只要用户重复几次就行。只要将注册信息写入数据库，然后将消息写入到消息队列中，就立即返回，延迟就只需要 55ms，发送注册邮件和发送注册短信会由其他微服务从消息队列中取出消息进行处理，这样就可以将延迟进行进一步缩短。&lt;/p&gt;
&lt;h4 id=&#34;2-解耦&#34;&gt;&lt;a href=&#34;#2-解耦&#34; class=&#34;headerlink&#34; title=&#34;2.解耦&#34;&gt;&lt;/a&gt;2.解耦&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2021/png/2648023/1621339118945-ef11d72e-bd9e-4778-831e-ab2af9656f81.png#align=left&amp;display=inline&amp;height=550&amp;margin=%5Bobject%20Object%5D&amp;name=%E6%88%AA%E5%B1%8F2021-05-18%2019.58.18.png&amp;originHeight=888&amp;originWidth=808&amp;size=261107&amp;status=done&amp;style=none&amp;width=500&#34; alt=&#34;截屏2021-05-18 19.58.18.png&#34;&gt;&lt;br&gt;当服务之间进行相互调用时，例如订单服务下单时需要调用库存服务进行出库操作，但是库存系统经常进行升级，导致接口参数经常发生变化，如果是使用 Feign 进行调用，当库存系统进行升级了，订单系统中的 Feign 接口就会发生变动。如果使用消息队列就可以进行解耦，当订单系统下订单后向消息队列中写入消息：某某下了一个订单，购置商品 xxx 几件，然后库存系统从消息队列中取出消息即可，这样就进行了解耦。&lt;/p&gt;",
            "author": { "@type": "Person", "name": "一止长渊" },
            "@type": "BlogPosting",
            "url": "http://example.com/2021/uncategorized/yuque/Message%20Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/index.html",
            "publisher": {
            "@type": "Organization",
            "logo": {
                "@type": "ImageObject",
                "url": "http://example.com/images/self-photo.jpeg"
            },
            "name": "一止长渊"
            },
            "headline": "Message Queue消息队列——RabbitMQ | 一止长渊的博客",
            "datePublished": "2021-05-18T11:29:27.000Z",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "http://example.com/2021/uncategorized/yuque/Message%20Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/index.html"
            },
            "@context": "http://schema.org"
        }
    </script>




    
    <meta name="google-site-verification" content="yizhichangyuan" />
    

    
    <meta property="algolia:search" data-application-id="HJSTQHS8PQ" data-api-key="1af8dce1713110d779f0514c752bf31c" data-index-name="blog">
    

    

    

    

    
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1646451311888.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1646451311888.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            gitalk: {
                enable: true,
                clientID: "",
                clientSecret: "",
                repo: "blog-comments",
                owner: "yizhichangyuan",
                admin: ["yizhichangyuan",],
                distractionFreeMode: true  // Facebook-like distraction free mode
            },
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = true

    </script>

<meta name="generator" content="Hexo 5.3.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/self-photo.jpeg" alt="一止长渊">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>一止长渊的博客</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">首页</a>
                
                <a href="/archives">存档</a>
                
                <a href="/photography">摄影</a>
                
            </div>
            <div class="header-menu-social">
                
    <a class="social" target="_blank" href="https://github.com/yizhichangyuan">
        <box-icon type='logo' name='github'></box-icon>
    </a>

    <a class="social" target="_blank" href="https://weibo.com/5827404079/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1">
        <box-icon type='logo' name='instagram'></box-icon>
    </a>

    <a class="social" target="_blank" href="https://unsplash.com/@yizhichangyuan">
        <box-icon type='logo' name='unsplash'></box-icon>
    </a>

            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">首页</a>
                    
                    <a href="/archives">存档</a>
                    
                    <a href="/photography">摄影</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-cl2ejptlr002vdjod98ga1n3i" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      Message Queue消息队列——RabbitMQ
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2021-05-18T11:29:27.000Z" itemprop="datePublished">2021-05-18</time>
</div>

            

            

            
            <div class="article-busuanzi">
                <span id="busuanzi_value_page_pv">N</span> 人看过
            </div>
            
                
            <div class="article-busuanzi">
                <span>字数：4.2k字 | 预计阅读时长：16分钟</span>
            </div>
        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <p>和队列 Queue 类似，不过消息队列是在分布式情况下，每个服务从一个消息队列中取出东西。消息保存到消息队列中，别的服务从消息中间件中取消息。</p>
<h3 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h3><p>异步、削峰、解耦</p>
<h4 id="1-异步"><a href="#1-异步" class="headerlink" title="1.异步"></a>1.异步</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1621338379093-fd517de9-ba79-42d8-9033-e7f33b406df1.png#align=left&display=inline&height=421&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2019.45.28.png&originHeight=1066&originWidth=1772&size=603370&status=done&style=none&width=700" alt="截屏2021-05-18 19.45.28.png"><br><strong>例如用户注册为例</strong><br>图 1：需要将用户信息写入到数据库中，然后发送注册邮件和注册短信，如果按照图 1 的方式顺序进行就会响应达到 150ms；<br>图 2：如果使用 CompletableFuture 进行异步编排，将发送注册邮件和发送注册信息进行并行处理，等待两者都完成就进行返回，则响应可以缩减到 100ms<br>图 3：其实我们并不关心发送注册邮件和短信是否成功，即使有时候是不成功的状态也是可以理解的，只要用户重复几次就行。只要将注册信息写入数据库，然后将消息写入到消息队列中，就立即返回，延迟就只需要 55ms，发送注册邮件和发送注册短信会由其他微服务从消息队列中取出消息进行处理，这样就可以将延迟进行进一步缩短。</p>
<h4 id="2-解耦"><a href="#2-解耦" class="headerlink" title="2.解耦"></a>2.解耦</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1621339118945-ef11d72e-bd9e-4778-831e-ab2af9656f81.png#align=left&display=inline&height=550&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2019.58.18.png&originHeight=888&originWidth=808&size=261107&status=done&style=none&width=500" alt="截屏2021-05-18 19.58.18.png"><br>当服务之间进行相互调用时，例如订单服务下单时需要调用库存服务进行出库操作，但是库存系统经常进行升级，导致接口参数经常发生变化，如果是使用 Feign 进行调用，当库存系统进行升级了，订单系统中的 Feign 接口就会发生变动。如果使用消息队列就可以进行解耦，当订单系统下订单后向消息队列中写入消息：某某下了一个订单，购置商品 xxx 几件，然后库存系统从消息队列中取出消息即可，这样就进行了解耦。</p>
<a id="more"></a>

<h4 id="3-削峰"><a href="#3-削峰" class="headerlink" title="3.削峰"></a>3.削峰</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1621339871581-11cd54ea-04c0-412e-a17a-1ef2f5f5ca39.png#align=left&display=inline&height=312&margin=%5Bobject%20Object%5D&name=image.png&originHeight=624&originWidth=1036&size=211628&status=done&style=none&width=518" alt="image.png"></p>
<p>在秒杀构成中，可以利用消息队列进行流量削峰，秒杀发出的用户请求写入到消息队列中，后端服务集群按顺序取出消息队列中的消息，可以避免大量请求挤兑后端服务，造成崩溃。</p>
<h3 id="二、概述"><a href="#二、概述" class="headerlink" title="二、概述"></a>二、概述</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1621342207669-656f1a3a-3cf3-4fb4-8a70-9400c6f8f44d.png#align=left&display=inline&height=200&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2020.50.03.png&originHeight=548&originWidth=1916&size=211690&status=done&style=none&width=700" alt="截屏2021-05-18 20.50.03.png"></p>
<ul>
<li><p><strong>点对点式：</strong>消息生产者将发送消息，将消息放入消息队列中，消息接收者可以有很多，通过监听队列，当队列中有消息内容时，就从消息队列中获取消息内容。</p>
<p>特点：消息具有唯一的发送者和接受者，但并不是只有一个接收者。（也就是消息只能被一个人来消费，但是可以有很多人来监听消息队列的动静，就和猪槽里喂饲料一样，一对一）</p>
</li>
<li><p><strong>发布订阅模式：</strong>消息发送者发送消息给消息队列，然后消息队列将消息发布到主题中，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息。</p>
</li>
</ul>
<p>特点：可以有很多接受者，一对多</p>
<p>消息队列协议：</p>
<ul>
<li>JMS（JAVA Message Service）JAVA 消息服务：基于 JVM 消息代理的规范，ActiveMQ、HornetMQ 是 JMS 实现。定义了通用的 Java api 接口</li>
<li>AMQP：RabbitMQ 是 AMQP 的实现，是一个消息代理的规范。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1621343032955-47b39c21-26e5-443c-82e6-0887dc9fb132.png#align=left&display=inline&height=389&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2021.03.47.png&originHeight=1086&originWidth=1954&size=355104&status=done&style=none&width=700" alt="截屏2021-05-18 21.03.47.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1621344118949-091ba092-f86c-4eb3-83eb-bfd04e85339a.png#align=left&display=inline&height=324&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2021.21.53.png&originHeight=924&originWidth=1998&size=255031&status=done&style=none&width=700" alt="截屏2021-05-18 21.21.53.png"></p>
<h3 id="三、RabbitMQ-概念"><a href="#三、RabbitMQ-概念" class="headerlink" title="三、RabbitMQ 概念"></a>三、RabbitMQ 概念</h3><p>生产者<strong>Publisher</strong>生产消息，发送的消息有消息头和消息体组成，其中消息体中最重要的是 route-key（路由键），消息发送给服务器，这个消息中间件服务器叫做<strong>Broker</strong>，生产者产生消息后会将消息通过<strong>Exchange 交换器路由</strong>给服务器中对应的<strong>队列</strong>，<strong>Exchange 交换器</strong>负责接收消息并进行消息分发；队列是用来存储消息；交换器与哪个队列进行绑定，是通过<strong>Binding</strong>进行消息队列和交换器之间的关联，一个绑定就是基于路由键将交换器和消息队列连接起来。消息消费者 Consumerr 和消息生产者 Publicsher 都是通过 Connection 与消息服务器建立连接进行通信，但是消费者有很多类型，例如用户、库存、订单等，一个客户端只会建立一条长连接，一条连接可以和多个队列进行连接，是通过 NIO 一条连接建立多个 Channel 信道，一条长连接可以有很多 Channel，消息的内容是通过信道来进行收发消息。虚拟主机就类似 Docker 中容器，表示一批交换器、消息队列和相关对象，一台服务器可以有多个虚拟主机，不同虚拟主机之间是相互隔离的。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1621350556332-79c7c809-a9b9-45a1-9aac-036203337bbc.png#align=left&display=inline&height=383&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2023.09.12.png&originHeight=1426&originWidth=2608&size=416860&status=done&style=none&width=700" alt="截屏2021-05-18 23.09.12.png"></p>
<h3 id="四、Docker-安装-RabbitMQ"><a href="#四、Docker-安装-RabbitMQ" class="headerlink" title="四、Docker 安装 RabbitMQ"></a>四、Docker 安装 RabbitMQ</h3><pre><code class="bash">docker run -d --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1621351042008-1e185d28-2e4d-4094-af17-ed69f61a75ac.png#align=left&display=inline&height=161&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2023.17.18.png&originHeight=670&originWidth=2076&size=209920&status=done&style=none&width=500" alt="截屏2021-05-18 23.17.18.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1621352580685-6af15dd9-35bd-4129-8109-1e55e747992f.png#align=left&display=inline&height=109&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-18%2023.42.44.png&originHeight=512&originWidth=2344&size=82331&status=done&style=none&width=500" alt="截屏2021-05-18 23.42.44.png"><br>默认登陆用户密码都是 guest</p>
<h3 id="五、细节概念"><a href="#五、细节概念" class="headerlink" title="五、细节概念"></a>五、细节概念</h3><h4 id="1-交换机-Exchange-类型"><a href="#1-交换机-Exchange-类型" class="headerlink" title="1.交换机 Exchange 类型"></a>1.交换机 Exchange 类型</h4><ul>
<li>direct：直接，精确匹配 route-key 转发；单播类型（一个）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1621397034487-5d4e993d-1145-4bb9-abee-d23141387e93.png#align=left&display=inline&height=241&margin=%5Bobject%20Object%5D&name=image.png&originHeight=482&originWidth=1714&size=389189&status=done&style=none&width=857" alt="image.png"></p>
<ul>
<li>fanout：扇出；广播类型（全部）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1621397056743-18d9d236-6b18-4529-a989-8c01d976556a.png#align=left&display=inline&height=213&margin=%5Bobject%20Object%5D&name=image.png&originHeight=426&originWidth=1658&size=394451&status=done&style=none&width=829" alt="image.png"></p>
<ul>
<li>topic：主题（自定义）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1621397078985-394c449e-d534-4d1c-a113-c86af70a1dc9.png#align=left&display=inline&height=210&margin=%5Bobject%20Object%5D&name=image.png&originHeight=420&originWidth=1678&size=545021&status=done&style=none&width=839" alt="image.png"></p>
<ul>
<li>headers：匹配消息头而不是路由键，几乎不用到。与 direct 完全一致，但是性能会差很多</li>
</ul>
<h4 id="2-自定义交换机"><a href="#2-自定义交换机" class="headerlink" title="2.自定义交换机"></a>2.自定义交换机</h4><p>1）定义一个交换机<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1621398243171-96dc772b-8c0c-4dd6-86e8-a44f8049bb39.png#align=left&display=inline&height=358&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-19%2012.17.37.png&originHeight=1686&originWidth=3294&size=394112&status=done&style=none&width=700" alt="截屏2021-05-19 12.17.37.png"><br>2）创建一个队列<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1621398567981-56965058-3bd2-4d76-9213-667ab2e4a36f.png#align=left&display=inline&height=261&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-19%2012.27.41.png&originHeight=1236&originWidth=3310&size=259660&status=done&style=none&width=700" alt="截屏2021-05-19 12.27.41.png"><br>3）交换机绑定队列<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1621399243063-2f6a3761-f532-4e05-962b-be4578a58449.png#align=left&display=inline&height=306&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-05-19%2012.39.32.png&originHeight=1420&originWidth=3250&size=217029&status=done&style=none&width=700" alt="截屏2021-05-19 12.39.32.png"></p>
<h3 id="六、整合-RabbitMQ"><a href="#六、整合-RabbitMQ" class="headerlink" title="六、整合 RabbitMQ"></a>六、整合 RabbitMQ</h3><h4 id="1-引入-spring-boot-starter-amqp"><a href="#1-引入-spring-boot-starter-amqp" class="headerlink" title="1.引入 spring-boot-starter-amqp"></a>1.引入 spring-boot-starter-amqp</h4><pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>给容器中自动配置了 RabiitAutoConfiguration</p>
<h4 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h4><pre><code class="yaml">spring:
  rabbitmq:
    host: 192.168.2.200
    port: 5672
    virtual-host: /
</code></pre>
<h4 id="3-使用-AmqpAdmin-创建-Exchagne-Queue-Binding"><a href="#3-使用-AmqpAdmin-创建-Exchagne-Queue-Binding" class="headerlink" title="3.使用 AmqpAdmin 创建 Exchagne/Queue/Binding"></a>3.使用 AmqpAdmin 创建 Exchagne/Queue/Binding</h4><pre><code class="java">    @Autowired
    AmqpAdmin amqpAdmin;

    /**
     * 使用AmqpAdmin创建Exchange
     */
    @Test
    public void testCreateExchange()&#123;
        /**
         * public DirectExchange(String name, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments)
         */
        DirectExchange directExchange = new DirectExchange(&quot;hello-java-exchange&quot;, true, false,  null);
        amqpAdmin.declareExchange(directExchange);
        log.info(&quot;Exchange:&#123;&#125;创建成功&quot;, directExchange.getName());
    &#125;

    /**
     * 使用AmqpAdmin创建Queue
     */
    @Test
    public void testCreateQueue()&#123;
        /**
         * 队列名称、是否持久化、是否排他（只能独占一条连接）、是否自动删除、参数
         * public Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)
         */
        Queue queue = new Queue(&quot;hello-java-queue&quot;, true, false, false, null);
        amqpAdmin.declareQueue(queue);
        log.info(&quot;queue:&#123;&#125;创建成功&quot;, queue.getName());
    &#125;

    /**
     * 使用AmqpAdmin创建Binding，连接Exchange和Queue
     */
    @Test
    public void testCreateBinding()&#123;
        /**
         * 目的地、目的地类型、交换机名称、路由键、参数
         * 将exchange指定的交换机和destination目的地进行绑定，使用routingKey作为指定的路由键
         * public Binding(String destination, Binding.DestinationType destinationType, String exchange, String routingKey, Map&lt;String, Object&gt; arguments)
         */
        Binding binding = new Binding(&quot;hello-java-queue&quot;, Binding.DestinationType.QUEUE, &quot;hello-java-exchange&quot;, &quot;hello.java&quot;, null);
        amqpAdmin.declareBinding(binding);
        log.info(&quot;Binding创建成功&quot;);
    &#125;
</code></pre>
<h4 id="4-测试发送消息"><a href="#4-测试发送消息" class="headerlink" title="4.测试发送消息"></a>4.测试发送消息</h4><p>可以将字符串或者对象作为消息发送，其中作为对象发送默认是使用 java 的序列化方式，为此对象必须实现 Serializable 接口；此外也可以向容器中注入 Jackson2JsonMessageConverter 将对象转为 JSON 字符串形式作为消息发送出去</p>
<pre><code class="java">@Configuration
public class MyRabbitConfig &#123;
    /**
    * 注入JSON消息转化器
       */
    @Bean
    public MessageConverter messageConverter()&#123;
        return new Jackson2JsonMessageConverter();
    &#125;
&#125;

    @Autowired
    RabbitTemplate rabbitTemplate;

    /**
     * 测试发送消息
     */
    @Test
    public void sendMessageTest()&#123;
        /**
         * 交换机名称、路由键、传递对象会自动序列化
         * public void convertAndSend(String exchange, String routingKey, Object object)
         */
        String msg =&quot;hello world&quot;;
        rabbitTemplate.convertAndSend(&quot;hello-java-exchange&quot;, &quot;hello.java&quot;, msg);
        log.info(&quot;消息&#123;&#125;已发送完成&quot;, msg);

        /**
         * 复杂对象作为消息发送，会使用序列化机制将对象写出去，要求对象必须实现Serializable
         * 可以在容器中注入MessageConverter将对象序列化为JSON
         */
        OrderReturnReasonEntity reasonEntity = new OrderReturnReasonEntity();
        reasonEntity.setId(1L);
        reasonEntity.setName(&quot;test&quot;);
        reasonEntity.setCreateTime(new Date());
        reasonEntity.setStatus(1);
        rabbitTemplate.convertAndSend(&quot;hello-java-exchange&quot;, &quot;hello.java&quot;, reasonEntity);
    &#125;
</code></pre>
<h4 id="5-接收消息"><a href="#5-接收消息" class="headerlink" title="5.接收消息"></a>5.接收消息</h4><p>接收消息本质上就是监听队列，当队列中有消息时，就从队列中取出消息<br>启动类上使用**@EnableRabbit**开启监听消息</p>
<p>@RabbitListener 必须在容器中使用，标记在类或者方法上<br><strong>1.@RabbitListener 标记在方法上时</strong>，<strong>当监听的队列中有消息时会自动的执行该方法</strong><br><strong>方法可以添加的参数</strong></p>
<ul>
<li>可以写成原生消息类型 Message，里面有消息头和消息体</li>
</ul>
<pre><code class="java">    @RabbitListener(queues=&#123;&quot;hello-java-queue&quot;&#125;) // 组件必须在容器中才可以监听
    public void receiveMessageTest(Message message, OrderReturnReasonEntity content)&#123;
        byte[] body = message.getBody(); // 消息体
        MessageProperties properties = message.getMessageProperties(); // 消息头
        System.out.println(&quot;接收的消息为&quot; + body);
    &#125;
</code></pre>
<pre><code class="bash">接收的消息为(Body:&#39;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;test&quot;,&quot;sort&quot;:null,&quot;status&quot;:1,&quot;createTime&quot;:1621413291190&#125;&#39; MessageProperties [headers=&#123;__TypeId__=com.lookstarry.doermail.order.entity.OrderReturnReasonEntity&#125;, contentType=application/json, contentEncoding=UTF-8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=false, receivedExchange=hello-java-exchange, receivedRoutingKey=hello.java, deliveryTag=1, consumerTag=amq.ctag-L8NVu3eZmSZRW2aWG85apA, consumerQueue=hello-java-queue])==&gt;类型：class org.springframework.amqp.core.Message
</code></pre>
<ul>
<li>T&lt;发送消息的类型&gt; 后面添加上获取消息体的类型，可以通过该类直接获取内容</li>
</ul>
<pre><code class="java">    /**
     * queues：声明需要监听的所有队列
     * org.springframework.amqp.core.Message
     * 参数是接收消息的类型
     * 1、可以写成原生消息类型Message，里面有消息头和消息体
     * 2、T&lt;发送消息的类型&gt; 后面添加上获取消息体的类型
     */
    @RabbitListener(queues=&#123;&quot;hello-java-queue&quot;&#125;) // 组件必须在容器中才可以监听
    public void receiveMessageTest(Message message, OrderReturnReasonEntity content)&#123;
        byte[] body = message.getBody(); // 消息体
        MessageProperties properties = message.getMessageProperties(); // 消息头

        System.out.println(&quot;接收的消息为&quot; + message + &quot;==&gt;内容：&quot; + content);
    &#125;
</code></pre>
<pre><code class="bash">接收的消息为(Body:&#39;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;test&quot;,&quot;sort&quot;:null,&quot;status&quot;:1,&quot;createTime&quot;:1621412699210&#125;&#39; MessageProperties [headers=&#123;__TypeId__=com.lookstarry.doermail.order.entity.OrderReturnReasonEntity&#125;, contentType=application/json, contentEncoding=UTF-8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=false, receivedExchange=hello-java-exchange, receivedRoutingKey=hello.java, deliveryTag=1, consumerTag=amq.ctag-DSSfCxc2AVxmeRo2rhEu0Q, consumerQueue=hello-java-queue])==&gt;内容：OrderReturnReasonEntity(id=1, name=test, sort=null, status=1, createTime=Wed May 19 16:24:59 CST 2021)
</code></pre>
<ul>
<li>Channel</li>
</ul>
<p><strong>2.@RabbitListener 标记在类上，@RabbitHandler 标记在该类某个方法上</strong><br>这样做的好处就是，队列中有很多不同类型的消息，就可以通过@RabbitHandler 标记的不同的方法来处理不同类型的消息</p>
<pre><code class="bash">@RabbitListener(queues=&#123;&quot;hello-java-queue&quot;&#125;) // 组件必须在容器中才可以监听
@Service(&quot;orderItemService&quot;)
public class OrderItemServiceImpl extends ServiceImpl&lt;OrderItemDao, OrderItemEntity&gt; implements OrderItemService &#123;
    /**
     * queues：声明需要监听的所有队列
     * org.springframework.amqp.core.Message
     * 参数是接收消息的类型
     * 1、可以写成原生消息类型Message，里面有消息头和消息体
     * 2、T&lt;发送消息的类型&gt; 后面添加上获取消息体的类型
     * 3、Channel：当前传输数据的通道
     *
     * Queue：队列可以有很多人都来监听，只要收到消息队列就会删除消息，而且只能有一个人收到此消息
     * 场景：
     *      1）订单服务启动多个：同一个消息，只能有一个客户端能够收到
     *      2）只有一个消息完全处理完，方法运行结束才可以接收到下一个消息
     */
    // 处理OrderReturnReasonEntity类型的消息
    @RabbitHandler
    public void receiveMessageTest(Message message,
                                   OrderReturnReasonEntity content,
                                   Channel channel) throws InterruptedException &#123;
        byte[] body = message.getBody(); // 消息体
        MessageProperties properties = message.getMessageProperties(); // 消息头
        System.out.println(&quot;接收的消息为&quot; + message + &quot;==&gt;内容：&quot; + content);
        System.out.println(&quot;消息处理完成&quot; + content.getName());
    &#125;

        // 处理String类型的消息
    @RabbitHandler
    public void receiveMessage2(Message message,
                                   String content)&#123;
        byte[] body = message.getBody(); // 消息体
        MessageProperties properties = message.getMessageProperties(); // 消息头
        System.out.println(&quot;接收的消息为&quot; + message + &quot;==&gt;内容：&quot; + content);
        System.out.println(&quot;消息处理完成&quot; + content);
    &#125;
</code></pre>
<h4 id="七、RabbitMQ-消息确认机制——可靠抵达"><a href="#七、RabbitMQ-消息确认机制——可靠抵达" class="headerlink" title="七、RabbitMQ 消息确认机制——可靠抵达"></a>七、RabbitMQ 消息确认机制——可靠抵达</h4><p><strong>背景：</strong><br>在分布式系统中，有很多的微服务连接到队列进行监听消息，可能会由于网络的抖动、服务宕机等原因，导致消息的丢失，比如发送者发消息时丢失了或者消费者在消费消息的时候消息未收到；因此为了保证消息不丢失，可靠抵达，可以使用事务消息，为此引入确认机制。**<br><strong>事务消息：</strong><br>发消息的时候首先客户端会建立连接，会在通道中发送消息，可以设置通道为事务模式，只有当整个消息发送出去，消费者消费了消息，一连串全部成功，才算消息发送成功；不过这样会导致性能下降 250 倍<br><strong>因此引入确认机制，</strong>RabbitMQ 的确认机制是使用了两端机制，一端是生产者两种回调确认模式，一端是消费者一种 ack 模式</p>
<ul>
<li><strong>publisher confirmCallback 确认模式</strong></li>
</ul>
<p>当生产者将消息发送给 Broker 服务器，服务器收到了消息就会回调<strong>confirmCallback</strong>，就可以知道哪些消息抵达了服务器</p>
<ul>
<li><strong>publisher returnCallback 未投递到队列 queue 退出模式</strong></li>
</ul>
<p>服务器收到消息后，会使用 Exchange 交换机投递到 queue 中，如果消息没有成功投递到队列中，就会使用 returnCallback</p>
<ul>
<li><strong>consumer ack 机制</strong></li>
</ul>
<p>消费者如果从队列中成功取到了消息，就会发送一个 ack 确认，Queue 收到 ack 确认后，就会将该消息从队列中删除</p>
<h4 id="1-发送端确认confirmCallback配置，服务器收到消息就会回调"><a href="#1-发送端确认confirmCallback配置，服务器收到消息就会回调" class="headerlink" title="1.发送端确认confirmCallback配置，服务器收到消息就会回调"></a>1.发送端确认<strong>confirmCallback</strong>配置，服务器收到消息就会回调</h4><p>1）开启发送端确认</p>
<pre><code class="yaml">spring:
  rabbitmq:
    # 开启发送端确认
    publisher-confirms: true
</code></pre>
<p>2）手动编码发送端确认<strong>confirmCallback</strong>执行逻辑<br>只要消息正确抵达了 Broker，就会执行该逻辑</p>
<pre><code class="java">@Configuration
public class MyRabbitConfig &#123;
    @Autowired
    RabbitTemplate rabbitTemplate;

    @Bean
    public MessageConverter messageConverter()&#123;
        return new Jackson2JsonMessageConverter();
    &#125;

    /**
     * 定制RabbitTemplate
     */
    @PostConstruct // MyRabbitConfig调用构造器创建完成以后最后执行该方法
    public void initRabbitTemplate()&#123;
        // 设置确认回调
        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() &#123;
            /**
             * 只要消息正确抵达了Broker，就会执行该逻辑ack=true
             * @param correlationData 当前消息的唯一关联数据（这个是消息的唯一id）
             * @param ack 消息是否成功收到
             * @param cause 失败的原因
             */
            @Override
            public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123;
                System.out.println(&quot;confirm...correlationData[&quot; +correlationData + &quot;]==&gt;ack[&quot; + ack + &quot;]==&gt;cause[&quot; + cause + &quot;]&quot;);
            &#125;
        &#125;);
    &#125;
</code></pre>
<p><strong>2.发送端投递到队列失败 retureCallback 设置</strong></p>
<pre><code class="yaml">spring:
  rabbitmq:
        # 开启发送端消息抵达队列的确认
    publisher-returns: true
    # 只要抵达队列以异步模式优先回调这个returnConfigrm
    template:
      mandatory: true
</code></pre>
<pre><code class="yaml">// 消息抵达队列的确认回调
rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() &#123;
/**
* 只要消息没有投递给指定的队列，就会出发这个失败回调
* @param message 投递失败的消息详细信息
* @param replayCode 回复的状态码
* @param replayText 回复的文本内容
* @param exchange 当时这个消息发送给哪个交换机
* @param routingKey 该消息的消息头使用的路由键
*/
@Override
public void returnedMessage(Message message, int replayCode, String replayText, String exchange, String routingKey) &#123;
System.out.println(&quot;Fail Message[&quot; + message + &quot;]==&gt;relayCode[&quot; + replayCode + &quot;]==&gt;replayText[&quot; + replayText + &quot;]==&gt;routingKey[&quot; + routingKey + &quot;]&quot;);
&#125;
&#125;);
</code></pre>
<h6 id="3-消费端确认"><a href="#3-消费端确认" class="headerlink" title="3.消费端确认"></a><strong>3.消费端确认</strong></h6><p>保证每个消息被正确消费，此时 broker 才会从队列中移除该消息；默认是自动确认的，只要消息接收到，客户端会自动确认，服务端就会移除这个消息 1.问题：我们收到很多消息，自动回复给服务器 ack，但是其实只有一个消息处理成功服务器就宕机了，所以就出现了消息丢失。<br>解决：手动确认，只要明确告诉 MQ，消息被签收，没有 ack，消息就一直会是 unack，即使 Consumer 宕机，消息也不会丢失，会重新变为 Ready，下一次有新的 Consumer 连接进来就会把消息发给他。 2.如何手动签收：<br>在处理消息结束后，利用 Channel 的 basicAck 来进行签收；此外也可以利用 basicNAck 来拒绝签收，拒签的货物可以指定 requeue 来指定是否重新入队，false 就直接会丢弃，true 会重新入队（和快递签收退签是否退回给商家）<br>业务成功完成就应该签收，业务失败就手动拒签</p>
<pre><code class="yaml">spring:
    rabbitmq:
    listener:
          simple:
            acknowledge-mode: manual
</code></pre>
<pre><code class="java">    @RabbitHandler
    public void receiveMessageTest(Message message,
                                   OrderReturnReasonEntity content,
                                   Channel channel) throws InterruptedException &#123;
        byte[] body = message.getBody(); // 消息体
        MessageProperties properties = message.getMessageProperties(); // 消息头
        System.out.println(&quot;接收的消息为&quot; + message + &quot;==&gt;内容：&quot; + content);
        System.out.println(&quot;消息处理完成&quot; + content.getName());
        // 通道内按顺序自增的
        long deliveryTag = message.getMessageProperties().getDeliveryTag();
        System.out.println(&quot;deliveryTag==&gt;&quot; + deliveryTag);
        try &#123;
            if(deliveryTag % 2 == 0)&#123;
                // 手动签收消息，false为非批量签收模式
                channel.basicAck(deliveryTag, false);
                System.out.println(&quot;签收了货物...&quot; + deliveryTag);
            &#125;else&#123;
                // 拒绝签收消息
                // 第三个参数requeue为是否重新入队: false直接丢弃 true发回服务器，重新入队
                channel.basicNack(deliveryTag, false, true);
                System.out.println(&quot;没有签收了货物...&quot; + deliveryTag);
            &#125;
        &#125; catch (IOException e) &#123;
            // 网络中断会造成异常
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>

        </div>

    </div>

    

    

    

    
  <div class="article-copyright hairline">
    <p>
      本作品采用  <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议 (CC BY-NC-ND 4.0)</a> 进行许可。
    </p>
  </div>
  

    

    
<nav class="article-nav">
  
    <a href="/2021/uncategorized/yuque/Feign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%A2%E5%A4%B1%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%97%AE%E9%A2%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          Feign远程调用丢失请求头问题
        
      </div>
    </a>
  
  
    <a href="/2021/uncategorized/yuque/JUC%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92%E2%80%94%E2%80%94CompletableFuture/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">JUC异步编排——CompletableFuture</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=Message Queue消息队列——RabbitMQ - 一止长渊的博客&url=http://example.com/2021/uncategorized/yuque/Message%20Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/">
            <box-icon type='logo' name='twitter'></box-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=Message Queue消息队列——RabbitMQ - 一止长渊的博客&u=http://example.com/2021/uncategorized/yuque/Message%20Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/">
            <box-icon name='facebook-square' type='logo' ></box-icon>
        </a>
        <!-- <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=Message Queue消息队列——RabbitMQ - 一止长渊的博客&url=http://example.com/2021/uncategorized/yuque/Message%20Queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a> -->
    </section>

</article>








<section class="comments">
    <div id="gitalk-container"></div>
</section>









<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</div>
                </section>
            </section>

            
            <aside class="sidebar sidebar-search-fix">
                

    <div class="search">
    <div class="has-icon-right">
        <input type="text" class="form-input" id="search" placeholder="SEARCH" autocomplete="off">
        <div class="form-icon">
            <box-icon name='search' color="#3c4859"></box-icon>
        </div>
    </div>
    <div class="search-result" id="search-ps"></div>
</div>


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E4%B8%9C%E6%88%98%E4%BA%89%E5%8F%B2/">中东战争史</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BF%AE%E8%A1%8C/">修行</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Elasticsearch/" rel="tag">Elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kaptcha/" rel="tag">Kaptcha</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MYSQL%E9%9B%86%E7%BE%A4/" rel="tag">MYSQL集群</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nacos/" rel="tag">Nacos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zxing/" rel="tag">Zxing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2/" rel="tag">历史</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/" rel="tag">数据校验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%AD%E9%93%BE/" rel="tag">短链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/" rel="tag">缓存一致性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2021/uncategorized/yuque/ThreadPoolExecutor/">ThreadPoolExecutor</a>
          </li>
        
          <li>
            <a href="/2021/uncategorized/yuque/%E4%B8%AD%E6%96%AD/">中断</a>
          </li>
        
          <li>
            <a href="/2021/uncategorized/yuque/ConcurrentHashMap%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/">ConcurrentHashMap原理初探</a>
          </li>
        
          <li>
            <a href="/2021/uncategorized/yuque/%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%90%8C%E6%97%B6%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%90%8C%E7%B1%BB%E5%9E%8BBean%E5%AD%98%E5%9C%A8/">容器中同时有两个同类型Bean存在</a>
          </li>
        
          <li>
            <a href="/2021/uncategorized/yuque/%E7%A7%92%E6%9D%80/">秒杀</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            一止长渊的博客 &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>


<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>





<script src="/dist/build.js?1646451311888.js"></script>


<script src="/dist/custom.js?1646451311888.js"></script>



<!-- 百度链接提交 -->
<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>



<!-- Google Analytics-->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXX-X"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-XXXXX-X');
</script>









</body>

</html>