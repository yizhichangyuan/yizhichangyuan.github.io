<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>ElasticSearch | 一止长渊的博客</title>

    <meta name="description" content="&lt;p&gt;Elastcisearch 是分布式的文档存储。它能以实时的方式存储和检索复杂的数据结构——序列化成为&lt;strong&gt;JSON 文档&lt;/strong&gt;。换句话说，一旦一个文档被存储在 Elasticsearch 中，它就是可以被集群中的任意节点检索到。&lt;br&gt;尽管现存的 NoSQL 解决方案允许我们以文档的形式存储对象，但是他们仍旧需要我们思考如何查询我们的数据，以及确定哪些字段需要被索引以加快数据检索。在 Elasticsearch 中， &lt;strong&gt;每个字段的所有数据都是默认被索引的&lt;/strong&gt; 。 即每个字段都有为了快速检索设置的&lt;strong&gt;专用倒排索引&lt;/strong&gt;。而且，不像其他多数的数据库，它能在   同一个查询中   使用所有这些倒排索引，并以惊人的速度返回结果。&lt;br&gt;ES 的底层是开源库 Lucene，ES 是对 Lucene 的封装，对外提供了&lt;strong&gt;REST API&lt;/strong&gt;的操作接口，外部调用就是向 ES 发送请求即可，做到开箱即用。&lt;/p&gt;">
    <meta name="keywords" content="JAVA 后端 Spring">

    

    <meta property="og:locale" content="en" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content= "ElasticSearch | 一止长渊的博客"  />
    <meta property="og:description" content= "&lt;p&gt;Elastcisearch 是分布式的文档存储。它能以实时的方式存储和检索复杂的数据结构——序列化成为&lt;strong&gt;JSON 文档&lt;/strong&gt;。换句话说，一旦一个文档被存储在 Elasticsearch 中，它就是可以被集群中的任意节点检索到。&lt;br&gt;尽管现存的 NoSQL 解决方案允许我们以文档的形式存储对象，但是他们仍旧需要我们思考如何查询我们的数据，以及确定哪些字段需要被索引以加快数据检索。在 Elasticsearch 中， &lt;strong&gt;每个字段的所有数据都是默认被索引的&lt;/strong&gt; 。 即每个字段都有为了快速检索设置的&lt;strong&gt;专用倒排索引&lt;/strong&gt;。而且，不像其他多数的数据库，它能在   同一个查询中   使用所有这些倒排索引，并以惊人的速度返回结果。&lt;br&gt;ES 的底层是开源库 Lucene，ES 是对 Lucene 的封装，对外提供了&lt;strong&gt;REST API&lt;/strong&gt;的操作接口，外部调用就是向 ES 发送请求即可，做到开箱即用。&lt;/p&gt;" />
    <meta property="og:url" content="https://yizhichangyuan.github.io/2021/uncategorized/yuque/ElasticSearch/index.html" />
    <meta property="og:site_name" content="" />
    <meta property="article:author" content="一止长渊" />
    <meta property="article:publisher" content="" />
    <meta property="og:description" content="&lt;p&gt;Elastcisearch 是分布式的文档存储。它能以实时的方式存储和检索复杂的数据结构——序列化成为&lt;strong&gt;JSON 文档&lt;/strong&gt;。换句话说，一旦一个文档被存储在 Elasticsearch 中，它就是可以被集群中的任意节点检索到。&lt;br&gt;尽管现存的 NoSQL 解决方案允许我们以文档的形式存储对象，但是他们仍旧需要我们思考如何查询我们的数据，以及确定哪些字段需要被索引以加快数据检索。在 Elasticsearch 中， &lt;strong&gt;每个字段的所有数据都是默认被索引的&lt;/strong&gt; 。 即每个字段都有为了快速检索设置的&lt;strong&gt;专用倒排索引&lt;/strong&gt;。而且，不像其他多数的数据库，它能在   同一个查询中   使用所有这些倒排索引，并以惊人的速度返回结果。&lt;br&gt;ES 的底层是开源库 Lucene，ES 是对 Lucene 的封装，对外提供了&lt;strong&gt;REST API&lt;/strong&gt;的操作接口，外部调用就是向 ES 发送请求即可，做到开箱即用。&lt;/p&gt;" />
    <meta name="twitter:title" content="ElasticSearch | 一止长渊的博客"/>
    <meta name="twitter:description" content="&lt;p&gt;Elastcisearch 是分布式的文档存储。它能以实时的方式存储和检索复杂的数据结构——序列化成为&lt;strong&gt;JSON 文档&lt;/strong&gt;。换句话说，一旦一个文档被存储在 Elasticsearch 中，它就是可以被集群中的任意节点检索到。&lt;br&gt;尽管现存的 NoSQL 解决方案允许我们以文档的形式存储对象，但是他们仍旧需要我们思考如何查询我们的数据，以及确定哪些字段需要被索引以加快数据检索。在 Elasticsearch 中， &lt;strong&gt;每个字段的所有数据都是默认被索引的&lt;/strong&gt; 。 即每个字段都有为了快速检索设置的&lt;strong&gt;专用倒排索引&lt;/strong&gt;。而且，不像其他多数的数据库，它能在   同一个查询中   使用所有这些倒排索引，并以惊人的速度返回结果。&lt;br&gt;ES 的底层是开源库 Lucene，ES 是对 Lucene 的封装，对外提供了&lt;strong&gt;REST API&lt;/strong&gt;的操作接口，外部调用就是向 ES 发送请求即可，做到开箱即用。&lt;/p&gt;"/>
    <script type="application/ld+json">
        {
            "description": "&lt;p&gt;Elastcisearch 是分布式的文档存储。它能以实时的方式存储和检索复杂的数据结构——序列化成为&lt;strong&gt;JSON 文档&lt;/strong&gt;。换句话说，一旦一个文档被存储在 Elasticsearch 中，它就是可以被集群中的任意节点检索到。&lt;br&gt;尽管现存的 NoSQL 解决方案允许我们以文档的形式存储对象，但是他们仍旧需要我们思考如何查询我们的数据，以及确定哪些字段需要被索引以加快数据检索。在 Elasticsearch 中， &lt;strong&gt;每个字段的所有数据都是默认被索引的&lt;/strong&gt; 。 即每个字段都有为了快速检索设置的&lt;strong&gt;专用倒排索引&lt;/strong&gt;。而且，不像其他多数的数据库，它能在   同一个查询中   使用所有这些倒排索引，并以惊人的速度返回结果。&lt;br&gt;ES 的底层是开源库 Lucene，ES 是对 Lucene 的封装，对外提供了&lt;strong&gt;REST API&lt;/strong&gt;的操作接口，外部调用就是向 ES 发送请求即可，做到开箱即用。&lt;/p&gt;",
            "author": { "@type": "Person", "name": "一止长渊" },
            "@type": "BlogPosting",
            "url": "https://yizhichangyuan.github.io/2021/uncategorized/yuque/ElasticSearch/index.html",
            "publisher": {
            "@type": "Organization",
            "logo": {
                "@type": "ImageObject",
                "url": "https://yizhichangyuan.github.io/images/self-photo.jpeg"
            },
            "name": "一止长渊"
            },
            "headline": "ElasticSearch | 一止长渊的博客",
            "datePublished": "2021-04-12T13:54:50.000Z",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "https://yizhichangyuan.github.io/2021/uncategorized/yuque/ElasticSearch/index.html"
            },
            "@context": "http://schema.org"
        }
    </script>




    
    <meta name="google-site-verification" content="yizhichangyuan" />
    

    
    <meta property="algolia:search" data-application-id="HJSTQHS8PQ" data-api-key="1af8dce1713110d779f0514c752bf31c" data-index-name="blog">
    

    

    

    

    
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1646451311888.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1646451311888.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            gitalk: {
                enable: true,
                clientID: "",
                clientSecret: "",
                repo: "blog-comments",
                owner: "yizhichangyuan",
                admin: ["yizhichangyuan",],
                distractionFreeMode: true  // Facebook-like distraction free mode
            },
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = true

    </script>

<meta name="generator" content="Hexo 5.3.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/self-photo.jpeg" alt="一止长渊">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>一止长渊的博客</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">首页</a>
                
                <a href="/archives">存档</a>
                
                <a href="/photography">摄影</a>
                
            </div>
            <div class="header-menu-social">
                
    <a class="social" target="_blank" href="https://github.com/yizhichangyuan">
        <box-icon type='logo' name='github'></box-icon>
    </a>

    <a class="social" target="_blank" href="https://weibo.com/5827404079/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1">
        <box-icon type='logo' name='instagram'></box-icon>
    </a>

    <a class="social" target="_blank" href="https://unsplash.com/@yizhichangyuan">
        <box-icon type='logo' name='unsplash'></box-icon>
    </a>

            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">首页</a>
                    
                    <a href="/archives">存档</a>
                    
                    <a href="/photography">摄影</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-cl2elp1xt002qcpop379efzyy" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      ElasticSearch
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2021-04-12T13:54:50.000Z" itemprop="datePublished">2021-04-12</time>
</div>

            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Elasticsearch/" rel="tag">Elasticsearch</a></li></ul>
            </div>
            

            
            <div class="article-busuanzi">
                <span id="busuanzi_value_page_pv">N</span> 人看过
            </div>
            
                
            <div class="article-busuanzi">
                <span>字数：6.5k字 | 预计阅读时长：28分钟</span>
            </div>
        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <p>Elastcisearch 是分布式的文档存储。它能以实时的方式存储和检索复杂的数据结构——序列化成为<strong>JSON 文档</strong>。换句话说，一旦一个文档被存储在 Elasticsearch 中，它就是可以被集群中的任意节点检索到。<br>尽管现存的 NoSQL 解决方案允许我们以文档的形式存储对象，但是他们仍旧需要我们思考如何查询我们的数据，以及确定哪些字段需要被索引以加快数据检索。在 Elasticsearch 中， <strong>每个字段的所有数据都是默认被索引的</strong> 。 即每个字段都有为了快速检索设置的<strong>专用倒排索引</strong>。而且，不像其他多数的数据库，它能在   同一个查询中   使用所有这些倒排索引，并以惊人的速度返回结果。<br>ES 的底层是开源库 Lucene，ES 是对 Lucene 的封装，对外提供了<strong>REST API</strong>的操作接口，外部调用就是向 ES 发送请求即可，做到开箱即用。</p>
<a id="more"></a>

<p><strong><em>注意！！！ES7.x 已经移除 types(类似于 MySQL 中的表)的支持，8.x 将不再支持</em></strong><br><strong><em>注意 kibana、ES、IK 分词插件版本要对应，本文使用版本均为 6.8.4</em></strong></p>
<h3 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1618236147408-58773255-c9b0-41fd-aad6-dae7e2bc62ab.png#align=left&display=inline&height=271&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-12%2022.02.21.png&originHeight=992&originWidth=1970&size=255178&status=done&style=none&width=539" alt="截屏2021-04-12 22.02.21.png"></p>
<h4 id="1、Index（索引）"><a href="#1、Index（索引）" class="headerlink" title="1、Index（索引）"></a>1、Index（索引）</h4><p>动词：相当于 MySQL 中的 insert<br>名词：相当于 MySQL 中的 database</p>
<h4 id="2、Type（类型）"><a href="#2、Type（类型）" class="headerlink" title="2、Type（类型）"></a>2、Type（类型）</h4><p>在 Index（索引中），可以定义一个或多个类型。<br>类似于 MySQL 中的 Table，每一种类型的数据放在一起</p>
<h4 id="3、Document（文档）"><a href="#3、Document（文档）" class="headerlink" title="3、Document（文档）"></a>3、Document（文档）</h4><p>保存在某个索引（Index）下，某种类型（Type）的一个数据（Document）。ES 中每条记录是以 JSON 文档的格式存储的，相当于 MySQL 中的一条记录</p>
<h4 id="4、倒排索引"><a href="#4、倒排索引" class="headerlink" title="4、倒排索引"></a>4、倒排索引</h4><p>就是每个分词对应于哪些文档的 id<br>插入一条记录，就会将该数据进行分词，然后每个分词都有对应一个记录，该记录记下该分词出现在哪些文档中<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1618236219246-5f98988b-3d9c-4ac3-82d7-884a982ad74a.png#align=left&display=inline&height=257&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-12%2022.03.34.png&originHeight=932&originWidth=1810&size=201859&status=done&style=none&width=500" alt="截屏2021-04-12 22.03.34.png"><br>查询时也会将查询的语句进行分词，然后统计哪些记录命中的分词数多计算相关性得分，返回评分的结果列表。</p>
<h3 id="二、Docker-安装"><a href="#二、Docker-安装" class="headerlink" title="二、Docker 安装"></a>二、Docker 安装</h3><h4 id="1、下载镜像文件"><a href="#1、下载镜像文件" class="headerlink" title="1、下载镜像文件"></a>1、下载镜像文件</h4><pre><code class="bash">docker pull elasticsearch:7.4.2 # 存储和检索数据
docker pull kibana:7.4.2  # 可视化界面：方便可视化检索数据
</code></pre>
<h4 id="2、创建-ES-实例"><a href="#2、创建-ES-实例" class="headerlink" title="2、创建 ES 实例"></a>2、创建 ES 实例</h4><pre><code class="bash"># 将docker中ES容器文件挂在到外部
mkdir -p /mydata/elasticsearch/config
mkdir -p /mydata/elasticsearch/data
mkdir -p /mydata/elasticsearch/plugins
chmod -R 777 /mydata
# 将ES配置为可以被远程的任何机器访问
echo &quot;http.host: 0.0.0.0&quot; &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml

# 9200端口为外面向ES发送REST API端口，9300为ES集群间相互通信端口
# discovery.type=single-node ES以单节点运行
# -Xms64m -Xmx128m 非常重要，不设置初始堆和最大堆的大小，ES会默认抢占所有内存，会造成卡死
# -v 将ES容器的文件关联到外面文件下，实现外面修改容器里面也同时修改，plugins实现以后在外面安装插件重启就可以了
docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \
-e &quot;discovery.type=single-node&quot; \
-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \
-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \
-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \
-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \
-d elasticsearch:6.8.4

# 服务如果没启动，查看启动日志
docker logs -f -t --tail 20 elasticsearch
# 如果是Caused by: java.nio.file.AccessDeniedException: /usr/share/elasticsearch/data/nodes
# 则使用以下语句授权
chmod 777 -R /mydata/elasticsearch/

# 自动重启
docker update elasticsearch --restart=always
</code></pre>
<p>浏览器访问虚拟机 IP+9200 端口出现以下界面即成功<img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1618406487226-62461211-07c5-4429-84a6-3134fdddabc7.png#align=left&display=inline&height=209&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-14%2021.21.18.png&originHeight=684&originWidth=1680&size=181649&status=done&style=none&width=514" alt="截屏2021-04-14 21.21.18.png"></p>
<h4 id="3、安装-Kibana-实例（可视化界面）"><a href="#3、安装-Kibana-实例（可视化界面）" class="headerlink" title="3、安装 Kibana 实例（可视化界面）"></a>3、安装 Kibana 实例（可视化界面）</h4><pre><code class="bash"># 这里的ip填写为虚拟机的ip 192.168.2.200，端口为前面ES容器内9200映射到宿主机的端口（前提是虚拟机关闭了防火墙，并且配置了桥接网络）
docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.2.200:9200 -p 5601:5601 -d kibana:6.8.4
docker update kibana --restart=always
</code></pre>
<p>浏览器访问<a href="http://192.168.2.200:5601（这里为虚拟机的ip）">http://192.168.2.200:5601（这里为虚拟机的ip）</a><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1618406614859-1f12ee25-0b64-47e9-b567-f36f0b001f1e.png#align=left&display=inline&height=1124&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-14%2021.23.23.png&originHeight=1124&originWidth=3360&size=327689&status=done&style=none&width=3360" alt="截屏2021-04-14 21.23.23.png"></p>
<h3 id="三、ES-实践"><a href="#三、ES-实践" class="headerlink" title="三、ES 实践"></a>三、ES 实践</h3><p>ES 是以 REST API 提供服务，外界向接口发送请求即可<br>下面的地址默认前缀都为<strong>http://**</strong>192.168.2.200:9200**</p>
<h4 id="1、查看结点信息"><a href="#1、查看结点信息" class="headerlink" title="1、查看结点信息"></a>1、查看结点信息</h4><ul>
<li>GET /_cat/nodes 查看 ES 集群所有结点信息</li>
<li>GET /_cat/health 查看 ES 集群健康</li>
<li>GET /_cat/master 查看 ES 集群的主节点信息</li>
<li>GET /_cat/indices 查看 ES 集群的所有索引信息（相当于 MySQL 中的 show databases）</li>
</ul>
<h4 id="2、索引一个文档（保存）"><a href="#2、索引一个文档（保存）" class="headerlink" title="2、索引一个文档（保存）"></a>2、索引一个文档（保存）</h4><p>保存一个数据：保存在哪个索引的哪个类型下，指定用哪一个唯一标识，对应的数据以 JSON 形式放置在请求 Body。<br>请求方法：PUT 或 POST 都可以，PUT 时需要指定唯一标识（否则出错），POST 时可以指定唯一标识也可以不指定（ES 会分配一个唯一标识）</p>
<ul>
<li>PUT customer/external/1</li>
</ul>
<pre><code class="json">&#123;
  &quot;name&quot;: &quot;John Doe&quot;
&#125;
</code></pre>
<p>响应：</p>
<pre><code class="json">&#123;
  &quot;_index&quot;: &quot;customer&quot;, // 索引：对应MySQL中的数据库
  &quot;_type&quot;: &quot;external&quot;, // 类型：对应MySQL中的表
  &quot;_id&quot;: &quot;1&quot;, // 标识
  &quot;_version&quot;: 1, // 版本号：发送多次则是一个更新操作，版本号会逐渐加1递增
  &quot;result&quot;: &quot;created&quot;, // 结果：第一次发送为created，第二次及以后则是更新updated，与Map相似
  &quot;_shards&quot;: &#123;
    // 分片：集群时会用到
    &quot;total&quot;: 2,
    &quot;successful&quot;: 1,
    &quot;failed&quot;: 0
  &#125;,
  &quot;_seq_no&quot;: 0,
  &quot;_primary_term&quot;: 1
&#125;
</code></pre>
<table>
<thead>
<tr>
<th>保存/更新</th>
<th>携带 id</th>
<th>不携带 id</th>
</tr>
</thead>
<tbody><tr>
<td>PUT</td>
<td>必须项，更新保存二合一</td>
<td>报错</td>
</tr>
<tr>
<td>POST</td>
<td>非必须，更新保存二合一</td>
<td>新增操作</td>
</tr>
</tbody></table>
<h4 id="3、查询数据"><a href="#3、查询数据" class="headerlink" title="3、查询数据"></a>3、查询数据</h4><p>GET /customer/external/1<br>响应：</p>
<pre><code class="json">&#123;
  &quot;_index&quot;: &quot;customer&quot;,
  &quot;_type&quot;: &quot;external&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 5,
  &quot;_seq_no&quot;: 5, //并发控制字段，序列号（每次更新自动加1），与_primary_term搭配可以作为乐观锁
  &quot;_primary_term&quot;: 1, // 主分片，主分片重新分配，如重启，就会变化
  &quot;found&quot;: true,
  &quot;_source&quot;: &#123;
    // 数据真正内容在_source中
    &quot;name&quot;: &quot;John Doe&quot;
  &#125;
&#125;
</code></pre>
<p>更新操作（乐观锁）携带上 ?if_seq_no=#{当前的版本号}&amp;if_primary_term=1</p>
<h6 id="乐观锁-CAS-举例："><a href="#乐观锁-CAS-举例：" class="headerlink" title="乐观锁(CAS)举例："></a><strong>乐观锁(CAS)举例：</strong></h6><p>例如两个线程多时发起 PUT 操作同一个文档，两个请求都先发起查询，发现当前文档版本号_seq_no 为 5，故同时发起 PUT 请求，仅在版本号为 1 时才 PUT 更新。<br>当第一个请求先达到 ES，发现版本号为 5 与自己预料的是正确的的，则将 name 修改为了 1，此时版本号_seq_no 会自动加一个随机数，改为了 8；<br>第二个请求后随后到达，准备将 name 修改 2，但是发现此时的版本号为 8 与自己预料的版本号 5 对不上，则该 PUT 操作就不会执行，会显示 409 错误码。</p>
<ul>
<li>PUT customer/external/1?if_seq_no=5&amp;if_primary_term=1 {“name”:”1”}</li>
<li>PUT customer/external/1?if_seq_no=5&amp;if_primary_term=1 {“name”:”2”}</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1618244009322-cdc02e3d-efea-4a5b-bc68-52275377c23c.png#align=left&display=inline&height=475&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-13%2000.13.25.png&originHeight=1678&originWidth=2474&size=303160&status=done&style=none&width=700" alt="截屏2021-04-13 00.13.25.png"></p>
<h4 id="4、更新数据"><a href="#4、更新数据" class="headerlink" title="4、更新数据"></a>4、更新数据</h4><ul>
<li>POST customer/external/1/_update</li>
</ul>
<p>请求体为：<br>{<br>“doc”:{<br>“name”: “John”<br>}<br>}</p>
<ul>
<li>POST customer/external/1</li>
</ul>
<p>请求体为：<br>{<br>“name”: “John”<br>}</p>
<ul>
<li><p>PUT customer/external/1</p>
<pre><code> 请求体为
</code></pre>
<p>{<br>“name”: “John”<br>}<br><strong>不同点：</strong><br>1.POST 发送请求携带上 update，请求体需要“doc”字段，doc 下才是文档数据<br>2.POST 发送请求携带上 update，会对比要更新的数据，</p>
</li>
<li><p>如果不存在则会将请求体数据创建</p>
</li>
<li><p>如果存在</p>
<ul>
<li>对比数据相同：则什么也不做，version、seq_no 都不会发生变化</li>
<li>对比数据不相同：发生更新操作，此时版本号才会发生变化（只有对比更新的数据有不同，才会进行更新）</li>
</ul>
<p>3.POST 不携带 update 和 PUT 请求，原来数据存在的话，都会发生更新，不会去进行对比，不存在就会创建<br>共同点： 1.都可以在原来的基础上，更新增加属性<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1618282759326-9f5fcad4-e8ae-408e-95d5-8081d102ec1d.png#align=left&display=inline&height=423&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-13%2010.47.17.png&originHeight=1400&originWidth=1080&size=170684&status=done&style=none&width=326" alt="截屏2021-04-13 10.47.17.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1618282779490-13195ce9-29e6-4bd4-a12f-ef9edc3c6ec6.png#align=left&display=inline&height=436&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-13%2010.47.48.png&originHeight=1392&originWidth=1080&size=190801&status=done&style=none&width=338" alt="截屏2021-04-13 10.47.48.png"></p>
</li>
</ul>
<h4 id="5、删除文档-amp-索引"><a href="#5、删除文档-amp-索引" class="headerlink" title="5、删除文档&amp;索引"></a>5、删除文档&amp;索引</h4><p>ES 中没有直接删除类型 Type</p>
<ul>
<li>DELETE /customer/external/1 删除文档</li>
<li>DELETE /customer 删除索引</li>
</ul>
<h4 id="6、bulk-批量-API"><a href="#6、bulk-批量-API" class="headerlink" title="6、bulk 批量 API"></a>6、bulk 批量 API</h4><p>在 kibana 中批量操作形式为：</p>
<ul>
<li>其中 action 可选为 index/create/update/delete</li>
<li>其中 metadata 可选为_index,_type,_id</li>
<li>其中 requestbody 为数据</li>
</ul>
<p>create 和 index 的区别：<br>如果数据存在，使用 create 操作失败，会提示文档已经存在，使用 index 则可以执行成功，如果存在会进行覆盖<br>bulk 批量操作，<strong>一个操作失败不会影响后续的操作</strong></p>
<pre><code class="json">&#123;&quot;action&quot;: &#123;metedta&#125;&#125;
&#123;requestbody&#125;
&#123;&quot;action&quot;: &#123;metedta&#125;&#125;
&#123;requestbody&#125;
</code></pre>
<p>举例：</p>
<ul>
<li>POST customer/external/_bulk</li>
</ul>
<pre><code class="json">&#123;&quot;index&quot;: &#123;&quot;_id&quot;: 1&#125;&#125;
&#123;&quot;name&quot;: &quot;1&quot;&#125;
&#123;&quot;index&quot;: &#123;&quot;_id&quot;: 2&#125;&#125;
&#123;&quot;name&quot;: &quot;2&quot;&#125;
</code></pre>
<ul>
<li>POST _bulk</li>
</ul>
<pre><code class="json">&#123;&quot;delete&quot;: &#123;&quot;_index&quot;:&quot;website&quot;, &quot;_type&quot;:&quot;blog&quot;,&quot;_id&quot;:&quot;123&quot;&#125;&#125; // 删除数据，初次会提示404，但不影响后续的操作
&#123;&quot;create&quot;: &#123;&quot;_index&quot;:&quot;website&quot;, &quot;_type&quot;:&quot;blog&quot;,&quot;_id&quot;:123&#125;&#125; // 创建数据
&#123;&quot;title&quot;:&quot;My first blog post&quot;&#125;
&#123;&quot;index&quot;: &#123;&quot;_index&quot;:&quot;website&quot;,&quot;_type&quot;:&quot;blog&quot;&#125;&#125; // 插入数据
&#123;&quot;title&quot;: &quot;My second blog post&quot;&#125;
&#123;&quot;update&quot;:&#123;&quot;_index&quot;:&quot;website&quot;, &quot;_type&quot;:&quot;blog&quot;,&quot;_id&quot;:&quot;123&quot;&#125;&#125; // 更新数据
&#123;&quot;doc&quot;:&#123;&quot;title&quot;:&quot;My updated blog post&quot;&#125;&#125;
</code></pre>
<h3 id="四、复杂检索"><a href="#四、复杂检索" class="headerlink" title="四、复杂检索"></a>四、复杂检索</h3><p>首先批量导入数据 POST /bank/account/_bulk<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/elastic/elasticsearch/master/docs/src/test/resources/accounts.json">https://raw.githubusercontent.com/elastic/elasticsearch/master/docs/src/test/resources/accounts.json</a><br>支持两种方式：</p>
<ul>
<li>将请求检索参数防止在 GET 请求路径背后 例如：<ul>
<li>GET /bank/_search?q=*&amp;sort=account_number:sort</li>
</ul>
</li>
<li>将请求检索参数放置在请求体中<ul>
<li>GET bank/_search</li>
</ul>
</li>
</ul>
<pre><code class="bash">&#123;
  &quot;query&quot;: &#123;
    &quot;match_all&quot;:&#123;&#125;
  &#125;,
  &quot;sort&quot;:[
    &#123;
      &quot;account_number&quot;: &quot;asc&quot;
    &#125;
    ]
&#125;
</code></pre>
<h4 id="1）基本语法格式"><a href="#1）基本语法格式" class="headerlink" title="1）基本语法格式"></a>1）基本语法格式</h4><p>ES 提供了一个可以执行查询的 json 风格的 DSL（domain-specific language 领域特定语言），也被称为 Query DSL。<br>1、全记录分页排序查询</p>
<pre><code class="bash"># 分页查询 from和size相当于MySQL中的limit
GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match_all&quot;:&#123;&#125;
  &#125;,
  &quot;sort&quot;: [
    &#123;
      &quot;balance&quot;: &#123;
        &quot;order&quot;: &quot;desc&quot;
      &#125;
    &#125;
  ],
  &quot;from&quot;: 0,
  &quot;size&quot;: 5
&#125;
</code></pre>
<p>2、特定字段分页排序查询</p>
<pre><code class="bash"># 查询特定字段的分页查询，_source指定查询字段
GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match_all&quot;:&#123;&#125;
  &#125;,
  &quot;sort&quot;: [
    &#123;
      &quot;balance&quot;: &#123;
        &quot;order&quot;: &quot;desc&quot;
      &#125;
    &#125;
  ],
  &quot;from&quot;: 0,
  &quot;size&quot;: 5,
  &quot;_source&quot;: [&quot;balance&quot;,&quot;firstname&quot;]
&#125;
</code></pre>
<p>3、match 查询、term 查询<br>term 查询，和 match 一样匹配某个属性的值，区别在于：</p>
<ul>
<li>term 查询只能用于查询非文本字段，查询文本字段会始终显示结果数为 0；或者 term 与 keyword 搭配，查询全量字符串</li>
<li>文本字段全文检索字段用 match</li>
</ul>
<p><strong>官方推荐：term 用于查询非文本字段，match 用于查询文本字段</strong></p>
<pre><code class="bash"># match用在字段为数字上相当于精确查询
GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match&quot;: &#123;
      &quot;account_number&quot;: 20
    &#125;
  &#125;
&#125;

# match模糊检索，会对检索条件进行分词匹配，不指定排序的话，结果会按照评分进行排序
GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match&quot;: &#123;
      &quot;address&quot;: &quot;mill lane&quot;
    &#125;
  &#125;
&#125;

# match全文检索，指定了排序则会按照排序字段进行排序
GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match&quot;: &#123;
      &quot;address&quot;: &quot;mill lane&quot;
    &#125;
  &#125;,
  &quot;sort&quot;: [
    &#123;
      &quot;balance&quot;: &#123;
        &quot;order&quot;: &quot;desc&quot;
      &#125;
    &#125;
  ]
&#125;

# term查询，和match一样匹配某个属性的值
# 只能用于查询非文本字段，查询文本字段会始终显示结果数为0
# 全文检索字段用match，其他非text字段用term
# 官方推荐：term用于查询非文本字段，match用于查询文本字段
GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;term&quot;: &#123;
      &quot;balance&quot;: 32838
    &#125;
  &#125;
&#125;

# 或者term与keyword搭配，查询全量字符串
GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;term&quot;: &#123;
      &quot;lastname.keyword&quot;: &quot;Bates&quot;
    &#125;
  &#125;
&#125;
</code></pre>
<p>4、match_phrase 短语匹配查询、keyword 全量精确查询<br>match_phrase 和 keyword 区别</p>
<ul>
<li>match_phrase 是将查询词不可拆分进行查询，只有完整包含了这个短语就可以得到匹配</li>
<li>keyword 则是精确查询，要求查询字段只能是该短语，而不是仅仅的包含关系</li>
</ul>
<pre><code class="bash"># match_pharse 短语匹配，将查询条件当成不可分割的短语进行匹配查询
# 包含了完成的短语mill lane会检索出来
GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match_phrase&quot;: &#123;
      &quot;address&quot;: &quot;789 Madison&quot;
    &#125;
  &#125;
&#125;

# 对于有一条记录为&quot;address&quot; : &quot;789 Madison Street&quot;
# match_phrase可以查到一条记录，而keyword差不到该条记录，是精确查询
# keyword全量精确匹配
GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match&quot;: &#123;
      &quot;address.keyword&quot; : &quot;789 Madison&quot;
    &#125;
  &#125;
&#125;
</code></pre>
<p>5、multi_match 多字段匹配查询</p>
<pre><code class="bash"># multi_match 多字段查询，query的词也会进行分词，两个字段有任意一个字段包含分的词检索出来，是or关系
GET /bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;multi_match&quot;: &#123;
      &quot;query&quot;: &quot;mill lane&quot;,
      &quot;fields&quot;: [&quot;state&quot;, &quot;address&quot;]
    &#125;
  &#125;
&#125;
</code></pre>
<p>6、bool 多重条件复合查询<br>bool 多重查询可以用上的条件交并集：must、must_not、should、filter<br>must 和 filter 配合 range 都可以进行过滤，区别在于：must 会贡献评分，但是 filter 不会贡献评分</p>
<ul>
<li>must：数组内的条件必须都满足</li>
</ul>
<pre><code class="bash"># bool中可以有多个查询条件，这里的must含义就是must数组中的条件都必须满足
GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;bool&quot;: &#123;
      &quot;must&quot;: [
        &#123;&quot;match&quot;:
          &#123;
            &quot;gender&quot;: &quot;F&quot;
          &#125;
        &#125;,
        &#123;
          &quot;match&quot;: &#123;
            &quot;address&quot;: &quot;mill&quot;
          &#125;
        &#125;
      ]
    &#125;
  &#125;
&#125;
</code></pre>
<ul>
<li>must_not：数组内的条件必须都不满足</li>
</ul>
<pre><code class="bash"># 复合查询，must：必须满足，must_not：必须不满足
# 查找出gender为M，address中有mill且age不是38的记录
GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;bool&quot;: &#123;
      &quot;must&quot;: [
        &#123;&quot;match&quot;:
          &#123;
            &quot;gender&quot;: &quot;M&quot;
          &#125;
        &#125;,
        &#123;
          &quot;match&quot;: &#123;
            &quot;address&quot;: &quot;mill&quot;
          &#125;
        &#125;
      ],
      &quot;must_not&quot;: [
        &#123;
          &quot;match&quot;:
          &#123;
            &quot;age&quot;: 38
          &#125;
        &#125;
      ]
    &#125;
  &#125;
&#125;
</code></pre>
<ul>
<li>should：数组内的条件最好满足，满足会有匹配度加分</li>
</ul>
<pre><code class="bash"># 复合查询，其中的should表示满足最好，不满足也可以，是加分项，满足了评分会更高
GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;bool&quot;: &#123;
      &quot;must&quot;: [
        &#123;&quot;match&quot;:
          &#123;
            &quot;gender&quot;: &quot;M&quot;
          &#125;
        &#125;,
        &#123;
          &quot;match&quot;: &#123;
            &quot;address&quot;: &quot;mill&quot;
          &#125;
        &#125;
      ],
      &quot;must_not&quot;: [
        &#123;
          &quot;match&quot;:
          &#123;
            &quot;age&quot;: 18
          &#125;
        &#125;
      ],
      &quot;should&quot;: [
        &#123;
          &quot;match&quot;:
          &#123;
          &quot;lastname&quot;: &quot;Wallace&quot;
          &#125;
        &#125;
      ]
    &#125;
  &#125;
&#125;
</code></pre>
<ul>
<li>filter：过滤</li>
</ul>
<pre><code class="bash"># must和filter配合range都可以进行过滤
# 区别在于：must会贡献评分，但是filter不会贡献评分
GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;bool&quot;: &#123;
      &quot;must&quot;: [
        &#123;
          &quot;range&quot;: &#123;
            &quot;age&quot;: &#123;
              &quot;gte&quot;: 18,
              &quot;lte&quot;: 30
            &#125;
          &#125;
        &#125;
      ]
    &#125;
  &#125;
&#125;

GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;bool&quot;: &#123;
      &quot;filter&quot;: &#123;
        &quot;range&quot;: &#123;
          &quot;age&quot;: &#123;
            &quot;gte&quot;: 18,
            &quot;lte&quot;: 30
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>
<p>7、aggragations 聚合查询<br>聚合提供了从数据中分组和提取数据的能力，最简单的聚合方法大致等于 SQL 中的 group by 和 SQL 聚合函数。ES 中，您有执行搜索返回 hits（命中结果），并且<strong>同时返回聚合结果</strong>，将一个响应中的所有 hits（命中结果）隔开的能力，可以执行查询和多个聚合，并且在<strong>一次使用中得到各自的返回结果</strong>，使用一次简洁和简化的 API 来避免网络往返<br>聚合语法：</p>
<pre><code class="bash">&quot;aggregations&quot; : &#123;
    &quot;&lt;aggregation_name&gt;&quot; : &#123;        # 这次聚合的名字，自定义方便展示在结果集中
        &quot;&lt;aggregation_type&gt;&quot; : &#123;    # 聚合类型
            &lt;aggregation_body&gt;      # 聚合体
        &#125;
        [,&quot;meta&quot; : &#123;  [&lt;meta_data_body&gt;] &#125; ]?
        [,&quot;aggregations&quot; : &#123; [&lt;sub_aggregation&gt;]+ &#125; ]?   # 聚合内嵌套子聚合，是在第一个查询的结果集上再次进行子聚合查询
    &#125;
    [,&quot;&lt;aggregation_name_2&gt;&quot; : &#123; ... &#125; ]* # 第二个聚合，和第一聚合是相互独立的
&#125;
</code></pre>
<pre><code class="bash"> 1.搜索address中包含mill的所有人的年龄分布以及平均年龄
 GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match&quot;: &#123;
      &quot;address&quot;: &quot;mill&quot;
    &#125;
  &#125;,
  &quot;aggs&quot;: &#123;
    &quot;aggAge&quot;: &#123;
      &quot;terms&quot;: &#123;   # terms相当于SQL中的count + group by，这里是先年龄分组计算每个分组总数
        &quot;field&quot;: &quot;age&quot;,
        &quot;size&quot;: 10
      &#125;
    &#125;,
    &quot;ageAvg&quot;:&#123;
      &quot;avg&quot;: &#123;   # 第二个聚合：计算平均年龄
        &quot;field&quot;: &quot;age&quot;
      &#125;
    &#125;
  &#125;
&#125;

2.按照年龄聚合，并且请求这些年龄段这些人的平均薪资
# 子查询，类似于MySQL中group by 然后avg
GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match_all&quot;: &#123;&#125;
  &#125;,
  &quot;aggs&quot;: &#123;
    &quot;aggAge&quot;: &#123;
      &quot;terms&quot;: &#123;
        &quot;field&quot;: &quot;age&quot;,
        &quot;size&quot;: 10
      &#125;,
      &quot;aggs&quot;: &#123;   # 子查询，在上一次聚合的结果中再次查询
        &quot;aggAvg&quot;: &#123;
          &quot;avg&quot;: &#123;
            &quot;field&quot;: &quot;balance&quot;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;

3.查出所有年龄分布，并且这些年龄中的性别为M的平均薪资和F的平均薪资以及这个年龄段的总体平均薪资
GET bank/_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match_all&quot;: &#123;&#125;
  &#125;,
  &quot;aggs&quot;: &#123;
    &quot;aggAge&quot;: &#123;
      &quot;terms&quot;: &#123;
        &quot;field&quot;: &quot;age&quot;, # 首先按照年龄进行聚合，terms计算count
        &quot;size&quot;: 100
      &#125;,
      &quot;aggs&quot;: &#123;
        &quot;avgGender&quot;: &#123;
          &quot;terms&quot;: &#123;
            &quot;field&quot;: &quot;gender.keyword&quot;  # 在年龄聚合的桶内再用性别进行聚合
          &#125;,
          &quot;aggs&quot;: &#123;
            &quot;aggBalance&quot;: &#123;
              &quot;avg&quot;: &#123;
                &quot;field&quot;: &quot;balance&quot;   # 在性别聚合的桶内在计算桶内的平均薪资
              &#125;
            &#125;
          &#125;
        &#125;,
        &quot;avgBalanceOnAge&quot;:&#123;
          &quot;avg&quot;: &#123;
            &quot;field&quot;: &quot;balance&quot; # 在年龄聚合的桶内计算平均薪资
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>
<h4 id="2）Mapping-映射"><a href="#2）Mapping-映射" class="headerlink" title="2）Mapping 映射"></a>2）Mapping 映射</h4><p>Mapping 是一个定义文档和所包含的字段如何保存和索引的，举例，使用 mapping 可以用来定义：</p>
<ul>
<li>哪个字符串字段应该被当成全文检索字段（full text fields）</li>
<li>哪个字段包含数字、日期、或者地理标志</li>
<li>日期的格式</li>
<li>自定义映射规则来执行动态添加属性</li>
</ul>
<pre><code class="bash">1.查询映射关系
PUT /my_index
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;age&quot;: &#123;&quot;type&quot;: &quot;Long&quot;&#125;,
      &quot;email&quot;: &#123;&quot;type&quot;: &quot;keyword&quot;&#125;,
      &quot;name&quot;: &#123;&quot;type&quot;: &quot;text&quot;&#125;
    &#125;
  &#125;
&#125;

2.建立索引的mapping映射
# ES7.x不再支持Types（类似MySQL中的表），所以这里没有在my_index在指定Types
# keyword会进行精确匹配，而不再分词全文匹配
PUT /my_index/_mapping
&#123;
  &quot;properties&quot;: &#123;
    &quot;employee_id&quot;: &#123;
      &quot;type&quot;: &quot;keyword&quot;,
      &quot;index&quot;: false
    &#125;
  &#125;
&#125;

3.修改指定索引的映射
3.1 增加新的字段
PUT /my_index/_mapping
&#123;
  &quot;properties&quot;: &#123;
    &quot;employee_id&quot;: &#123;
      &quot;type&quot;: &quot;keyword&quot;,
      &quot;index&quot;: false   # index表示employee_id不再可以被查询。（Fields that are not indexed are not queryable.）
    &#125;
  &#125;
&#125;
3.2 修改已有的字段映射
建立了映射后只能新增字段，而不能修改以前的字段属性，因为修改已存在的字段会让已经存在的数据失效。
如果你确实需要修改某个字段的映射，你需要重新建立一个映射关系的索引，然后将你的数据reindex到你新建的索引中

3.3 数据迁移到新的索引
3.3.1 首先建立新的索引mapping关系
PUT /newbank
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;account_number&quot;: &#123;
        &quot;type&quot;: &quot;long&quot;
      &#125;,
      &quot;address&quot;: &#123;
        &quot;type&quot;: &quot;text&quot;
      &#125;,
      &quot;age&quot;: &#123;
        &quot;type&quot;: &quot;integer&quot;
      &#125;,
      &quot;balance&quot;: &#123;
        &quot;type&quot;: &quot;long&quot;
      &#125;,
      &quot;city&quot;: &#123;
        &quot;type&quot;: &quot;keyword&quot;
      &#125;,
      &quot;email&quot;: &#123;
        &quot;type&quot;: &quot;keyword&quot;
      &#125;,
      &quot;employer&quot;: &#123;
        &quot;type&quot;: &quot;keyword&quot;
      &#125;,
      &quot;firstname&quot;: &#123;
        &quot;type&quot;: &quot;text&quot;
      &#125;,
      &quot;gender&quot;: &#123;
        &quot;type&quot;: &quot;keyword&quot;
      &#125;,
      &quot;lastname&quot;: &#123;
        &quot;type&quot;: &quot;text&quot;
      &#125;,
      &quot;state&quot;: &#123;
        &quot;type&quot;: &quot;keyword&quot;
      &#125;
    &#125;
  &#125;
&#125;

3.3.2 数据迁移reindex
【固定写法】对于没有建立类型的索引之间相互迁移数据
POST _reindex
&#123;
  &quot;source&quot;: &#123;
    &quot;index&quot;: &quot;twitter&quot;
  &#125;,
  &quot;dest&quot;: &#123;
    &quot;index&quot;: &quot;tweet  &quot;
  &#125;
&#125;

将旧索引的types下的数据进行迁移
因为我们旧索引建立了accout类型，索引迁移需要将索引和类型指定迁移到哪个索引下
POST _reindex
&#123;
  &quot;source&quot;: &#123;
    &quot;index&quot;: &quot;bank&quot;,
    &quot;type&quot;: &quot;account&quot;
  &#125;,
  &quot;dest&quot;: &#123;
    &quot;index&quot;: &quot;newbank&quot;
  &#125;
&#125;

# 可以看到数据迁移了过来，并且没有了type
# 以后都不用type，老的数据都可以通过reindex迁移过来
GET newbank/_search
</code></pre>
<h3 id="五、分词"><a href="#五、分词" class="headerlink" title="五、分词"></a>五、分词</h3><p>一个 tokenizer(分词器)接受一个字符流，将之分隔为独立的 tokens（词元，通常是独立的单词），然后输出 tokens 流。<br>例如：whitespace tokenizer 遇到空白字符时分隔文本，它会将文本”Quick brown fox!”分隔为【Quick，brown，fox！】<br>该 tokenizer（分词器）还负责记录各个 term（词条）的顺序或 position 位置（用于 phrase 短语和 word proximity 词近邻查询），以及 term（词条）所代表的原始 word（单词）的 start（起始）和 end（结束）的 character offsets（字符偏移量）用于高亮显示搜索的内容，ElasticSearch 提供了很多内置的分词器，可以用来构建 custom analyzers（自定义分词器）</p>
<pre><code class="bash"># 使用标准特定的分词器来进行分词
POST _analyze
&#123;
  &quot;analyzer&quot;: &quot;standard&quot;,
  &quot;text&quot;: &quot;The 2 QUICK Brown-Foxes jumped over the lazy dog&#39;s bone.&quot;
&#125;
</code></pre>
<h4 id="1、安装-ik-分词器"><a href="#1、安装-ik-分词器" class="headerlink" title="1、安装 ik 分词器"></a>1、安装 ik 分词器</h4><pre><code class="bash"># 进入容器挂载到外部的目录或未挂载进入容器内的目录
cd /mydata/elasticsearch/plugins
mkdir ik
cd ik
# 下载对应ES版本的ik分词器，这里选择7.4.2版本
wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.4.2/elasticsearch-analysis-ik-7.4.2.zip
unzip elasticsearch-analysis-ik-6.8.4.zip
cd ../..
chmod -R 777 plugins/
docker exec -it elasticsearch /bin/bash
cd /usr/share/elasticsearch/plugins/
# 查看安装好的插件
elasticsearch-plugin
# 重启让插件生效
docker restart elasticsearch
</code></pre>
<h4 id="2、测试-ik-分词器"><a href="#2、测试-ik-分词器" class="headerlink" title="2、测试 ik 分词器"></a>2、测试 ik 分词器</h4><p>ik 分词器提供两种:ik_smart 和 ik_max_word<br>ik_smart：智能分词，将输入词进行拆分<br>ik_max_word：保留所有可能搭配的词组组合</p>
<pre><code class="bash">POST _analyze
&#123;
  &quot;analyzer&quot;: &quot;ik_smart&quot;,
  &quot;text&quot;: &quot;我是中国人&quot;
&#125;
</code></pre>
<h4 id="3、自定义词库"><a href="#3、自定义词库" class="headerlink" title="3、自定义词库"></a>3、自定义词库</h4><p>ik 分词器有很多网络热词无法进行分词，所以这里我们可以自定义词库<br>我们可以指定一个远程的词库，让 ik 分词器可以去远程拉取最新的单词作为新的词元进行分解，这里建立远程的词库有两种方式：</p>
<ul>
<li>写一个项目来处理 ik 发送的请求，来返回新的单词</li>
<li>安装 Nginx，让 ik 分词器给 Nginx 发送请求，Ngix 将这个静态资源返回</li>
</ul>
<p>更改 ES 栈大小，之前是-Xmx128m，有点小，这里改为 512m，方法为将之前的 ES 容器删掉，因为之前是将容器内的数据挂载到了 centos 下的目录，所以数据不会丢失，新建一个 ES 容器再次挂载到这些目录即可</p>
<pre><code class="bash">docker rm -f elasticsearch
docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \
-e &quot;discovery.type=single-node&quot; \
-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \
-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \
-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \
-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \
-d elasticsearch:7.4.2
</code></pre>
<h4 id="4、安装-Ngnix"><a href="#4、安装-Ngnix" class="headerlink" title="4、安装 Ngnix"></a>4、安装 Ngnix</h4><pre><code class="bash"># 首先随便创建一个nginx实例，主要是将其中的配置复制出来
cd /mydata
mkdir nginx
docker pull nginx:1.10
docker run -p 80:80 --name nginx -d nginx:1.10
# 将nginx中的配置复制出来
docker container cp nginx:/etc/nginx .
cd nginx
ls # 就可以查看复制出来的文件
cd ..
mv nginx conf  # 将nginx配置移动到conf文件夹下
mkdir nginx   # 新建nginx文件夹
mv conf nginx/  # 将整个conf文件夹移动到nginx下
docker run -p 80:80 --name nginx \
-v /mydata/nginx/html:/usr/share/nginx/html \
-v /mydata/nginx/logs:/var/log/nginx \
-v /mydata/nginx/conf:/etc/nginx \
-d nginx:1.10
</code></pre>
<p>浏览器访问虚拟机 ip 地址<a target="_blank" rel="noopener" href="http://10.211.55.4/">http://192.168.2.200/</a>即成功<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1618475513956-bcc96616-d063-4bde-bf27-d49528764c9c.png#align=left&display=inline&height=442&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-15%2016.31.43.png&originHeight=442&originWidth=2274&size=72785&status=done&style=none&width=2274" alt="截屏2021-04-15 16.31.43.png"></p>
<pre><code class="bash">cd /ngnix/html
echo &#39;&lt;h1&gt;hello nginx&lt;/h1&gt;&#39; &gt;&gt; index.html
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1618406992476-4357d85f-d859-4f49-a90b-423fd7b544d6.png" alt="截屏2021-04-14 21.29.41.png" title="截屏2021-04-14 21.29.41.png"></p>
<h4 id="5、在-Nginx-下自定义静态资源词库"><a href="#5、在-Nginx-下自定义静态资源词库" class="headerlink" title="5、在 Nginx 下自定义静态资源词库"></a>5、在 Nginx 下自定义静态资源词库</h4><pre><code class="bash"># 在html下创建es文件夹，这里放入自定义分词器的词库内容
mkdir es
cd es
vi fenci.txt
# 输入你的词元，例如以下
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1618475710256-2c264bed-468e-4295-bbce-04b79e3e39e5.png#align=left&display=inline&height=42&margin=%5Bobject%20Object%5D&name=image.png&originHeight=84&originWidth=748&size=7474&status=done&style=none&width=374" alt="image.png"></p>
<pre><code class="bash"># 修改ik分词器请求分词词库地址
cd elasticsearch/plugins/ik
cd config
vi IKAnalyzer.cfg.xml
</code></pre>
<p>填充上 nginx 代理的静态资源地址（如果设置了 centos 的 ip 地址为宿主机 ip 地址同一个网段，则可以填写 centos 的地址，这里填写 192.168.2.200）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1618407369343-6ba4674e-7799-48c3-a81a-4933aa9f8ce1.png#align=left&display=inline&height=448&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-14%2021.35.37.png&originHeight=448&originWidth=1416&size=123513&status=done&style=none&width=1416" alt="截屏2021-04-14 21.35.37.png"></p>
<pre><code class="bash"># 让分词器生效
docker restart elasticsearch
docker update nginx --restart=always
</code></pre>
<p>地址栏访问 kibana，可以看到尚硅谷成为了一个词元，没有再被拆开为【尚，硅，谷】，说明自定义词库已经生效<br>（kibana 显示 not ready yet 的，注意因为我们新建了 ES 容器，对应容器的 ip 地址也发生了变化，所以新建 kibana 容器，指定好新的 ES 地址就可以访问了，上面步骤也都是有的）</p>
<h3 id><a href="#" class="headerlink" title></a><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1618475953260-6c5a7f1a-1a89-416b-b036-5cdc37020a92.png#align=left&display=inline&height=593&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2021-04-15%2016.38.59.png&originHeight=1894&originWidth=3196&size=757694&status=done&style=none&width=1000" alt="截屏2021-04-15 16.38.59.png"></h3><h3 id="五、java-操作-ES"><a href="#五、java-操作-ES" class="headerlink" title="五、java 操作 ES"></a>五、java 操作 ES</h3><p>java 操作 ES 有多重选择<br>1）9300：TCP</p>
<ul>
<li>spring-data-elasticsearch:transport-api.jar<ul>
<li>springboot 版本不同，transport-api.jar 不同，不能适配 es 高版本</li>
<li>7.x 已经不建议使用，8 以后就要废弃</li>
</ul>
</li>
<li>spring-boot-starter-data-elasticsearch</li>
</ul>
<p>请注意 springboot 版本以及 elasticsearch 版本，是对官方 restClient 更简化的封装，推荐<br>2）9200：HTTP</p>
<ul>
<li>JestClient：非官方，更新慢</li>
<li>RestTemplate：模拟发送 HTTP 请求，ES 很多 DSL 都要自己封装，麻烦</li>
<li>HttpClient：同上</li>
<li>Ok-Http：同上</li>
<li>Elasticsearch-Rest-Client：官方 RestClient，封装了 ES 操作，上手比较繁琐</li>
</ul>

        </div>

    </div>

    

    

    

    
  <div class="article-copyright hairline">
    <p>
      本作品采用  <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议 (CC BY-NC-ND 4.0)</a> 进行许可。
    </p>
  </div>
  

    

    
<nav class="article-nav">
  
    <a href="/2021/uncategorized/yuque/SpringBoot%E6%95%B4%E5%90%88ES%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          SpringBoot整合ES各种问题解决
        
      </div>
    </a>
  
  
    <a href="/2021/Spring/yuque/%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">统一异常处理</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=ElasticSearch - 一止长渊的博客&url=https://yizhichangyuan.github.io/2021/uncategorized/yuque/ElasticSearch/">
            <box-icon type='logo' name='twitter'></box-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=ElasticSearch - 一止长渊的博客&u=https://yizhichangyuan.github.io/2021/uncategorized/yuque/ElasticSearch/">
            <box-icon name='facebook-square' type='logo' ></box-icon>
        </a>
        <!-- <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=ElasticSearch - 一止长渊的博客&url=https://yizhichangyuan.github.io/2021/uncategorized/yuque/ElasticSearch/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a> -->
    </section>

</article>








<section class="comments">
    <div id="gitalk-container"></div>
</section>









<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</div>
                </section>
            </section>

            
            <aside class="sidebar sidebar-search-fix">
                

    <div class="search">
    <div class="has-icon-right">
        <input type="text" class="form-input" id="search" placeholder="SEARCH" autocomplete="off">
        <div class="form-icon">
            <box-icon name='search' color="#3c4859"></box-icon>
        </div>
    </div>
    <div class="search-result" id="search-ps"></div>
</div>


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E4%B8%9C%E6%88%98%E4%BA%89%E5%8F%B2/">中东战争史</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Elasticsearch/" rel="tag">Elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kaptcha/" rel="tag">Kaptcha</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MYSQL%E9%9B%86%E7%BE%A4/" rel="tag">MYSQL集群</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nacos/" rel="tag">Nacos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zxing/" rel="tag">Zxing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2/" rel="tag">历史</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/" rel="tag">数据校验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%AD%E9%93%BE/" rel="tag">短链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/" rel="tag">缓存一致性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2021/uncategorized/yuque/ThreadPoolExecutor/">ThreadPoolExecutor</a>
          </li>
        
          <li>
            <a href="/2021/uncategorized/yuque/%E4%B8%AD%E6%96%AD/">中断</a>
          </li>
        
          <li>
            <a href="/2021/uncategorized/yuque/ConcurrentHashMap%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/">ConcurrentHashMap原理初探</a>
          </li>
        
          <li>
            <a href="/2021/uncategorized/yuque/%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%90%8C%E6%97%B6%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%90%8C%E7%B1%BB%E5%9E%8BBean%E5%AD%98%E5%9C%A8/">容器中同时有两个同类型Bean存在</a>
          </li>
        
          <li>
            <a href="/2021/uncategorized/yuque/%E7%A7%92%E6%9D%80/">秒杀</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            一止长渊的博客 &copy; 2022<br>
            <!-- 不蒜子统计 -->
            <span id="busuanzi_container_site_pv">
                本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
            <span class="post-meta-divider">|</span>
            <span id="busuanzi_container_site_uv" style='display:none'>
                    本站访客数<span id="busuanzi_value_site_uv"></span>人
            </span>
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>


<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>





<script src="/dist/build.js?1646451311888.js"></script>


<script src="/dist/custom.js?1646451311888.js"></script>



<!-- 百度链接提交 -->
<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>



<!-- Google Analytics-->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXX-X"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-XXXXX-X');
</script>









</body>

</html>