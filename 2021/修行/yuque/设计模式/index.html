<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>设计模式 | 一止长渊的博客</title>

    <meta name="description" content="&lt;p&gt;设计模式的目的是为了降低代码的耦合性，同时也保证代码的可维护性和扩展性，一共有 23 种设计模式。&lt;br&gt;分为以下三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型设计模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注重于隐藏对象的创建逻辑，使用时无需 new 对象，直接获取对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构性模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注重已有对象之间的相互组合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行为型模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注重对象之间相互调用的行为，关注对象之间的通信&lt;/p&gt;">
    <meta name="keywords" content="JAVA 后端 Spring">

    

    <meta property="og:locale" content="en" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content= "设计模式 | 一止长渊的博客"  />
    <meta property="og:description" content= "&lt;p&gt;设计模式的目的是为了降低代码的耦合性，同时也保证代码的可维护性和扩展性，一共有 23 种设计模式。&lt;br&gt;分为以下三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型设计模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注重于隐藏对象的创建逻辑，使用时无需 new 对象，直接获取对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构性模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注重已有对象之间的相互组合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行为型模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注重对象之间相互调用的行为，关注对象之间的通信&lt;/p&gt;" />
    <meta property="og:url" content="https://yizhichangyuan.github.io/2021/%E4%BF%AE%E8%A1%8C/yuque/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html" />
    <meta property="og:site_name" content="" />
    <meta property="article:author" content="一止长渊" />
    <meta property="article:publisher" content="" />
    <meta property="og:description" content="&lt;p&gt;设计模式的目的是为了降低代码的耦合性，同时也保证代码的可维护性和扩展性，一共有 23 种设计模式。&lt;br&gt;分为以下三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型设计模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注重于隐藏对象的创建逻辑，使用时无需 new 对象，直接获取对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构性模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注重已有对象之间的相互组合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行为型模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注重对象之间相互调用的行为，关注对象之间的通信&lt;/p&gt;" />
    <meta name="twitter:title" content="设计模式 | 一止长渊的博客"/>
    <meta name="twitter:description" content="&lt;p&gt;设计模式的目的是为了降低代码的耦合性，同时也保证代码的可维护性和扩展性，一共有 23 种设计模式。&lt;br&gt;分为以下三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型设计模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注重于隐藏对象的创建逻辑，使用时无需 new 对象，直接获取对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构性模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注重已有对象之间的相互组合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行为型模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注重对象之间相互调用的行为，关注对象之间的通信&lt;/p&gt;"/>
    <script type="application/ld+json">
        {
            "description": "&lt;p&gt;设计模式的目的是为了降低代码的耦合性，同时也保证代码的可维护性和扩展性，一共有 23 种设计模式。&lt;br&gt;分为以下三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型设计模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注重于隐藏对象的创建逻辑，使用时无需 new 对象，直接获取对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构性模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注重已有对象之间的相互组合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行为型模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注重对象之间相互调用的行为，关注对象之间的通信&lt;/p&gt;",
            "author": { "@type": "Person", "name": "一止长渊" },
            "@type": "BlogPosting",
            "url": "https://yizhichangyuan.github.io/2021/%E4%BF%AE%E8%A1%8C/yuque/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html",
            "publisher": {
            "@type": "Organization",
            "logo": {
                "@type": "ImageObject",
                "url": "https://yizhichangyuan.github.io/images/self-photo.jpeg"
            },
            "name": "一止长渊"
            },
            "headline": "设计模式 | 一止长渊的博客",
            "datePublished": "2021-04-01T11:08:09.000Z",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "https://yizhichangyuan.github.io/2021/%E4%BF%AE%E8%A1%8C/yuque/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html"
            },
            "@context": "http://schema.org"
        }
    </script>




    
    <meta name="google-site-verification" content="yizhichangyuan" />
    

    
    <meta property="algolia:search" data-application-id="HJSTQHS8PQ" data-api-key="1af8dce1713110d779f0514c752bf31c" data-index-name="blog">
    

    

    

    

    
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1646451311888.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1646451311888.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            gitalk: {
                enable: true,
                clientID: "",
                clientSecret: "",
                repo: "blog-comments",
                owner: "yizhichangyuan",
                admin: ["yizhichangyuan",],
                distractionFreeMode: true  // Facebook-like distraction free mode
            },
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = true

    </script>

<meta name="generator" content="Hexo 5.3.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/self-photo.jpeg" alt="一止长渊">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>一止长渊的博客</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">首页</a>
                
                <a href="/archives">存档</a>
                
                <a href="/photography">摄影</a>
                
            </div>
            <div class="header-menu-social">
                
    <a class="social" target="_blank" href="https://github.com/yizhichangyuan">
        <box-icon type='logo' name='github'></box-icon>
    </a>

    <a class="social" target="_blank" href="https://weibo.com/5827404079/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1">
        <box-icon type='logo' name='instagram'></box-icon>
    </a>

    <a class="social" target="_blank" href="https://unsplash.com/@yizhichangyuan">
        <box-icon type='logo' name='unsplash'></box-icon>
    </a>

            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">首页</a>
                    
                    <a href="/archives">存档</a>
                    
                    <a href="/photography">摄影</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-cl2ejxn2x0035d2oc00os4e9s" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      设计模式
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2021-04-01T11:08:09.000Z" itemprop="datePublished">2021-04-01</time>
</div>

            
            <div class="article-category">
                <a class="article-category-link" href="/categories/%E4%BF%AE%E8%A1%8C/">修行</a>
            </div>
            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
            </div>
            

            
            <div class="article-busuanzi">
                <span id="busuanzi_value_page_pv">N</span> 人看过
            </div>
            
                
            <div class="article-busuanzi">
                <span>字数：7.4k字 | 预计阅读时长：33分钟</span>
            </div>
        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <p>设计模式的目的是为了降低代码的耦合性，同时也保证代码的可维护性和扩展性，一共有 23 种设计模式。<br>分为以下三类：</p>
<ul>
<li>创建型设计模式</li>
</ul>
<p>注重于隐藏对象的创建逻辑，使用时无需 new 对象，直接获取对象</p>
<ul>
<li>结构性模型</li>
</ul>
<p>注重已有对象之间的相互组合</p>
<ul>
<li>行为型模式</li>
</ul>
<p>注重对象之间相互调用的行为，关注对象之间的通信</p>
<a id="more"></a>

<h4 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h4><p>应用场景：如某一个系列有众多产品，但是属于同系，客户端只会用到这些同系产品的某一个，就可以使用工厂模式。<br>方式：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br>实现：同系产品都实现同一个接口（这里接口定义了行为），工厂类根据名称创建该接口的实例对象。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617275734178-cde98717-f4ee-4775-b9be-da55f521e9cd.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=image.png&originHeight=441&originWidth=772&size=61693&status=done&style=none&width=386" alt="image.png"></p>
<h4 id="2-抽象工厂模式"><a href="#2-抽象工厂模式" class="headerlink" title="2.抽象工厂模式"></a>2.抽象工厂模式</h4><p>抽象工厂模式简单而言就是工厂的工厂，我们通过一个超级工厂来创建其他的工厂，这里的抽象字面含义指的是工厂类是继承于抽象工厂类。<br>应用场景：如我们有多个系列，每个系列下有同族的众多产品，客户端只会用到某个系列中的某一个产品，这里就可以使用抽象工厂模式。这里每个系列下          的产品都实现该系列下定义的接口（接口提供该系列的行为模式），<strong>这里的系列就对应于工厂</strong>，工厂都继承自一个抽象工厂类（抽象工厂类定义了类模              板），用户通过超级工厂，选择某个系列就是选择某个工厂，然后通过该工厂来选择对象（该系列下的产品）。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617276071459-53e950e4-66cc-4ae8-ace7-dda07456da0b.png#align=left&display=inline&height=330&margin=%5Bobject%20Object%5D&name=image.png&originHeight=660&originWidth=1024&size=136342&status=done&style=none&width=512" alt="image.png"></p>
<h4 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h4><p>将构造函数私有化，然后暴露一个接口来返回创建好的单例对象，可以避免频繁地创建和销毁对象的开销<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617289119283-4d7c6029-ebb8-49b8-a59f-fc55f60833b1.png#align=left&display=inline&height=241&margin=%5Bobject%20Object%5D&name=image.png&originHeight=481&originWidth=457&size=38884&status=done&style=none&width=228.5" alt="image.png"><br>按照单例对象创建时间可分为：</p>
<ul>
<li>饿汉模式（类加载期间就创建好对象了，这是线程安全的）</li>
</ul>
<pre><code class="java">public class Singleton &#123;
    private static Singleton instance = new Singleton();
    private Singleton ()&#123;&#125;
    public static Singleton getInstance() &#123;
    return instance;
    &#125;
&#125;
</code></pre>
<ul>
<li>懒汉模式：只在用户第一次调用获取对象的方法时，才创建实例对象<ul>
<li>线程安全（创建实例的方法有 Sychronized 修饰）</li>
</ul>
</li>
</ul>
<pre><code class="java">public class Singleton &#123;
    private static Singleton instance;
    private Singleton ()&#123;&#125;

    public static Sychronized Singleton getInstance() &#123;
    if (instance == null) &#123;
        instance = new Singleton();
    &#125;
    return instance;
    &#125;
&#125;
</code></pre>
<pre><code>  - 线程不安全
</code></pre>
<pre><code class="java">public class Singleton &#123;
    private static Singleton instance;
    private Singleton ()&#123;&#125;

    public static Singleton getInstance() &#123;
    if (instance == null) &#123;
        instance = new Singleton();
    &#125;
    return instance;
    &#125;
&#125;
</code></pre>
<ul>
<li>双重锁（成员变量有 vloatile 修饰，防止指令重排）</li>
</ul>
<pre><code class="java">public class Singleton &#123;
    private volatile static Singleton singleton;
    private Singleton ()&#123;&#125;
    public static Singleton getSingleton() &#123;
    if (singleton == null) &#123;
        synchronized (Singleton.class) &#123;
        if (singleton == null) &#123;
            singleton = new Singleton();
        &#125;
        &#125;
    &#125;
    return singleton;
    &#125;
&#125;
</code></pre>
<ul>
<li>登记类</li>
</ul>
<p>与饿汉模式不同，这里成员变量初始化是在外部调用时才初始化，这是利用将初始化成员变量放置在内部类之中，这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，只有通过显式调用 getInstance 方法时，才会显式装载内部类 SingletonHolder 类</p>
<pre><code class="java">public class Singleton &#123;
    private static class SingletonHolder &#123;
    private static final Singleton INSTANCE = new Singleton();
    &#125;
    private Singleton ()&#123;&#125;
    public static final Singleton getInstance() &#123;
    return SingletonHolder.INSTANCE;
    &#125;
&#125;
</code></pre>
<h4 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4.建造者模式"></a>4.建造者模式</h4><p>从字面上看，一个复杂的对象是一步一步通过简单的对象建立组合起来的，一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。还是拿产品系列来说，两个系列的产品，要从每个系列中挑出一个产品进行搭配组合成套餐销售，这时候就可以利用建造者模式，将最后组合的套餐当做复杂的对象，这个套餐可以有两个系列中的产品自由组合。因为都是产品所以可以抽离出一个公共接口 Item，然后两个系列去实现 Item 接口，系列之下的产品同宗同源，但是有微小的差异，那么可以通过继承系列的类覆写实现微小差异，然后最后通过 Builder 自由组合这些产品。<br>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 <strong>Item 接口的实体类</strong>，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。然后我们创建一个 Meal 类，**带有 Item 的 ArrayList **和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo 类使用 MealBuilder 来创建一个 Meal。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617290426463-b6bfbbe4-bea8-4596-a557-26bd4b7ccf6a.png#align=left&display=inline&height=338&margin=%5Bobject%20Object%5D&name=image.png&originHeight=676&originWidth=804&size=65997&status=done&style=none&width=402" alt="image.png"></p>
<h4 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5.原型模式"></a>5.原型模式</h4><p>字面解释：就是以一个对象实例为原型，复制出一个新的对象<br>场景：创建一个对象需要消耗很多的资源，例如多次的 SQL 查询注入属性，我们就可以利用这种方式，可以避免创建对象时需要多次 SQL 查询，只要以第一次创建的对象为原型复制一个出<br>来就好了<br>如何使用：这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。<br>其中 Shape 抽象类需要实现 Cloneable 接口，用于后续的复制对象。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617291246404-dfcab769-5497-48cf-8286-d6d9daa81fcf.png#align=left&display=inline&height=298&margin=%5Bobject%20Object%5D&name=image.png&originHeight=596&originWidth=802&size=59416&status=done&style=none&width=401" alt="image.png"><br>抽象类实现 Cloneable 接口</p>
<pre><code class="java">public abstract class Shape implements Cloneable &#123;

   private String id;
   protected String type;

   abstract void draw();

   public String getType()&#123;
      return type;
   &#125;

   public String getId() &#123;
      return id;
   &#125;

   public void setId(String id) &#123;
      this.id = id;
   &#125;

   public Object clone() &#123;
      Object clone = null;
      try &#123;
         clone = super.clone();
      &#125; catch (CloneNotSupportedException e) &#123;
         e.printStackTrace();
      &#125;
      return clone;
   &#125;
&#125;
</code></pre>
<p>扩展抽象类</p>
<pre><code class="java">public class Rectangle extends Shape &#123;

   public Rectangle()&#123;
     type = &quot;Rectangle&quot;;
   &#125;

   @Override
   public void draw() &#123;
      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);
   &#125;
&#125;

public class Square extends Shape &#123;

   public Square()&#123;
     type = &quot;Square&quot;;
   &#125;

   @Override
   public void draw() &#123;
      System.out.println(&quot;Inside Square::draw() method.&quot;);
   &#125;
&#125;
</code></pre>
<p>原型提前创建，放入缓存中，后续取出为缓存的复制，避免了创建对象的资源消耗</p>
<pre><code class="java">import java.util.Hashtable;

public class ShapeCache &#123;

   private static Hashtable&lt;String, Shape&gt; shapeMap
      = new Hashtable&lt;String, Shape&gt;();

   public static Shape getShape(String shapeId) &#123;
      Shape cachedShape = shapeMap.get(shapeId);
      return (Shape) cachedShape.clone(); // 返回的缓存中的复制体
   &#125;

   // 对每种形状都运行数据库查询，并创建该形状
   // shapeMap.put(shapeKey, shape);
   // 例如，我们要添加三种形状
   public static void loadCache() &#123;
      Circle circle = new Circle();
      circle.setId(&quot;1&quot;);
      shapeMap.put(circle.getId(),circle);

      Square square = new Square();
      square.setId(&quot;2&quot;);
      shapeMap.put(square.getId(),square);

      Rectangle rectangle = new Rectangle();
      rectangle.setId(&quot;3&quot;);
      shapeMap.put(rectangle.getId(),rectangle);
   &#125;
&#125;
</code></pre>
<h4 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6.适配器模式"></a>6.适配器模式</h4><p>将现有的一个接口添加一些功能来应对用户新增加的需求，在原有的接口功能仍然可以使用的情况下，增加扩展性。<br>优点：适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作<br>缺点：过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现。<br>例如现有一个类 AudioPlayer 可以播放 mp3 格式歌曲，但用户希望 AudioPlayer 在现有基础上还可以播放 VLC 和 Mp4 格式歌曲，那么可以对 AudioPlayer 内部播放 Mp4 歌曲，实质上是调用的成员变量 MediaAdpter 对象中的 AdvancedMeidPlayer 进行播放相应格式歌曲。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617292901588-d7582ade-a2c2-4617-b560-8237792b67c8.png#align=left&display=inline&height=285&margin=%5Bobject%20Object%5D&name=image.png&originHeight=569&originWidth=1056&size=46113&status=done&style=none&width=528" alt="image.png"></p>
<p>MediaAdapter 实现 MediaPlayer 接口是为了保证和 AudioPlayer 同样的 Play 接口。</p>
<pre><code class="java">public class MediaAdapter implements MediaPlayer &#123;

   AdvancedMediaPlayer advancedMusicPlayer;

   public MediaAdapter(String audioType)&#123;
      if(audioType.equalsIgnoreCase(&quot;vlc&quot;) )&#123;
         advancedMusicPlayer = new VlcPlayer();
      &#125; else if (audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;
         advancedMusicPlayer = new Mp4Player();
      &#125;
   &#125;

   @Override
   public void play(String audioType, String fileName) &#123;
      if(audioType.equalsIgnoreCase(&quot;vlc&quot;))&#123;
         advancedMusicPlayer.playVlc(fileName);
      &#125;else if(audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;
         advancedMusicPlayer.playMp4(fileName);
      &#125;
   &#125;
&#125;
</code></pre>
<p>AudioPlayer 进行扩展</p>
<pre><code class="java">public class AudioPlayer implements MediaPlayer &#123;
   MediaAdapter mediaAdapter;

   @Override
   public void play(String audioType, String fileName) &#123;

      //播放 mp3 音乐文件的内置支持
      if(audioType.equalsIgnoreCase(&quot;mp3&quot;))&#123;
         System.out.println(&quot;Playing mp3 file. Name: &quot;+ fileName);
      &#125;
      //mediaAdapter 提供了播放其他文件格式的支持
      else if(audioType.equalsIgnoreCase(&quot;vlc&quot;)
         || audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;
         mediaAdapter = new MediaAdapter(audioType);
         mediaAdapter.play(audioType, fileName);
      &#125;
      else&#123;
         System.out.println(&quot;Invalid media. &quot;+
            audioType + &quot; format not supported&quot;);
      &#125;
   &#125;
&#125;
</code></pre>
<h4 id="7-桥接模式"><a href="#7-桥接模式" class="headerlink" title="7.桥接模式"></a>7.桥接模式</h4><p>桥接模式就是将抽象化和实现化解耦，简单意义上讲就是在底层 API 和用户使用之间加了一层，这一层的目的就是为了解耦，便于用户选择底层那个 API 来使用<br>这里的 Shape 就是中间层，这里的 Shape 是抽象类，将底层的 DrawAPI 和用户之间使用 Circle 解耦开，使得用户可以指定使用具体 DrawAPI 来进行使用，而不需改变原有的使用习惯。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617345092635-3f32bbf8-8a36-4e32-942f-09ecf6edc57d.png#align=left&display=inline&height=235&margin=%5Bobject%20Object%5D&name=image.png&originHeight=470&originWidth=760&size=44524&status=done&style=none&width=380" alt="image.png"><br>底层 API 统一接口</p>
<pre><code class="java">public interface DrawAPI &#123;
   public void drawCircle(int radius, int x, int y);
&#125;
</code></pre>
<p>中间层将底层 API 和用户使用隔离开，将使用和底层实现隔离开</p>
<pre><code class="java">public abstract class Shape &#123;
   protected DrawAPI drawAPI;
   protected Shape(DrawAPI drawAPI)&#123;
      this.drawAPI = drawAPI;
   &#125;
   public abstract void draw();
&#125;
</code></pre>
<p>用户使用</p>
<pre><code class="java">public class Circle extends Shape &#123;
   private int x, y, radius;

   public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123;
      super(drawAPI);
      this.x = x;
      this.y = y;
      this.radius = radius;
   &#125;

   public void draw() &#123;
      drawAPI.drawCircle(radius,x,y);
   &#125;
&#125;
</code></pre>
<h4 id="8-过滤器模式"><a href="#8-过滤器模式" class="headerlink" title="8.过滤器模式"></a>8.过滤器模式</h4><p>这种模式允许开发人员使用不同的标准来过滤一组对象，由于是不同的标准，可以抽象处一套标准的接口，接口主要目的就是过滤对象列表返回过滤后的对象。<br>还是拿产品说事，我们有一个系列，系列下有很多的产品，我们需要根据<strong>用户年龄段、用户性别等不同特征</strong>来过滤出适合用户的产品列表，这时候就可以使用过滤器模式，首先抽象出一个标准接口 Criteria，然后分别根据年龄段特征、用户性别特征分别实现一个 Criteria 接口，实现的标准就是过滤符合该特征的产品列表，最后我们可以根据用户的特征组合来搭配不同标准来过滤出符合用户的产品列表。</p>
<ul>
<li>Criteria 接口<ul>
<li>AgeCriteria 类：年龄段过滤标准</li>
<li>GenderCriteria 类：性别过滤标准</li>
</ul>
</li>
<li>推荐类 Recomend（内部就是用户年龄段和性别来使用相应标准来过滤产品）<ul>
<li>public Recomend(int age, String gender){内部就是根据 age 和 gender 选择相应过滤接口}</li>
<li>List<Product> filterByPersonFeature(List<Product>)</Product></Product></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617346488356-c0506c1d-d1a2-4262-af36-8e5bfcd24ae1.png#align=left&display=inline&height=344&margin=%5Bobject%20Object%5D&name=image.png&originHeight=687&originWidth=1086&size=70997&status=done&style=none&width=543" alt="image.png"></p>
<h4 id="9-组合模式"><a href="#9-组合模式" class="headerlink" title="9.组合模式"></a>9.组合模式</h4><p>组合模式根据树形结构的方式来构造对象，简单而言：就是一个对象内部有一个成员变量是自己对象组的列表，也就是相当于 children 的关系，该类提供了修改相同对象组的方式。<br>例如：一个雇员 A，手下也有很多雇员来管理，就形成了一个金字塔形的结构，雇员 A 提供了修改其雇员列表的接口，便于人员调动离职。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617347767243-7429d61f-b06e-4644-b1df-913f4a4ba5d6.png#align=left&display=inline&height=253&margin=%5Bobject%20Object%5D&name=image.png&originHeight=506&originWidth=487&size=32909&status=done&style=none&width=243.5" alt="image.png"></p>
<h4 id="10-装饰器模式"><a href="#10-装饰器模式" class="headerlink" title="10.装饰器模式"></a>10.装饰器模式</h4><p>装饰：从字面上看就是在原有底部部件不变化的情况下，加上一些功能。专业点就是向一个现有的对象增加一些功能而不改变其代码结构。<br>我们可以联想到子类继承的方式来实现这样的功能，该种模式是运用在不想增加很多子类的情况下还想扩展类的功能。<br>例如：我们只有绘制形状的对象 Circle 和 Rrctangle，我们想增加一项功能那就是可以绘制某种颜色的对象而不采用子类继承覆写的方式，就可以使用装饰器模式。这里的 ShapeDecorator 之所以去实现 Shape 接口，就是同一定义了 draw 行为模式，然后在 draw 中添加上自己的功能。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617348572554-70941dac-0068-4a2a-94d7-3f382db1d25d.png#align=left&display=inline&height=275&margin=%5Bobject%20Object%5D&name=image.png&originHeight=550&originWidth=854&size=54611&status=done&style=none&width=427" alt="image.png"></p>
<pre><code class="java">public abstract class ShapeDecorator implements Shape &#123;
   protected Shape decoratedShape;

   public ShapeDecorator(Shape decoratedShape)&#123;
      this.decoratedShape = decoratedShape;
   &#125;

   public void draw()&#123;
      decoratedShape.draw();
   &#125;
&#125;

public class RedShapeDecorator extends ShapeDecorator &#123;

   public RedShapeDecorator(Shape decoratedShape) &#123;
      super(decoratedShape);
   &#125;

   @Override
   public void draw() &#123;
      decoratedShape.draw();
      setRedBorder(decoratedShape);
   &#125;

   private void setRedBorder(Shape decoratedShape)&#123;
      System.out.println(&quot;Border Color: Red&quot;);
   &#125;
&#125;

public class DecoratorPatternDemo &#123;
   public static void main(String[] args) &#123;

      Shape circle = new Circle();
      ShapeDecorator redCircle = new RedShapeDecorator(new Circle());
      ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());
      //Shape redCircle = new RedShapeDecorator(new Circle());
      //Shape redRectangle = new RedShapeDecorator(new Rectangle());
      System.out.println(&quot;Circle with normal border&quot;);
      circle.draw();

      System.out.println(&quot;\nCircle of red border&quot;);
      redCircle.draw();

      System.out.println(&quot;\nRectangle of red border&quot;);
      redRectangle.draw();
   &#125;
&#125;
</code></pre>
<h4 id="11-外观模式"><a href="#11-外观模式" class="headerlink" title="11.外观模式"></a>11.外观模式</h4><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。例如：系统有很多功能，每个功能由一个类来实现，通过将各功能统一放置在一个接口中，然后让客户端调用这个接口，隐藏了各个功能的复杂性。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617350323504-a170c981-7114-4a82-8296-55ba6b965672.png#align=left&display=inline&height=298&margin=%5Bobject%20Object%5D&name=image.png&originHeight=595&originWidth=845&size=54485&status=done&style=none&width=422.5" alt="image.png"></p>
<h4 id="12-享元模式"><a href="#12-享元模式" class="headerlink" title="12.享元模式"></a>12.享元模式</h4><p>主要目的：重用现有的对象，避免频繁的创建和销毁类，核心就是利用工厂类中成员变量 HashMap 来存储创建过的对象，下次请求先去 HashMap 查找，如果没有则创建放入到 HashMap 中然后返回。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617350809235-6aba5b24-83ce-4b0e-a903-48e015e850c6.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&name=image.png&originHeight=517&originWidth=594&size=48426&status=done&style=none&width=297" alt="image.png"></p>
<pre><code class="java">import java.util.HashMap;

public class ShapeFactory &#123;
   private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;();

   public static Shape getCircle(String color) &#123;
      Circle circle = (Circle)circleMap.get(color);

      if(circle == null) &#123;
         circle = new Circle(color);
         circleMap.put(color, circle);
         System.out.println(&quot;Creating circle of color : &quot; + color);
      &#125;
      return circle;
   &#125;
&#125;
</code></pre>
<h4 id="13-代理模式"><a href="#13-代理模式" class="headerlink" title="13.代理模式"></a>13.代理模式</h4><p>代理模式就是有点类似 AOP 切向中的代理，利用接口实现返回与现有对象相同接口的对象，只不过这个对象织入了增强的逻辑。<br>核心：为其他对象提供一种代理以控制对这个对象的访问，主要为了隐藏创建对象的复杂性，例如需要大量的属性注入，这里就是可以利用代理模式来隐藏创建对象的复杂性，使得用户可以比较轻易的使用。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617351164692-41da655a-f4e7-4710-83a3-c85f26e1b792.png#align=left&display=inline&height=183&margin=%5Bobject%20Object%5D&name=image.png&originHeight=365&originWidth=742&size=38864&status=done&style=none&width=371" alt="image.png"></p>
<pre><code class="java">public class ProxyImage implements Image&#123;

   private RealImage realImage;
   private String fileName;

   public ProxyImage(String fileName)&#123;
      this.fileName = fileName;
   &#125;

   @Override
   public void display() &#123;
      if(realImage == null)&#123;
         realImage = new RealImage(fileName);
      &#125;
      realImage.display();
   &#125;
&#125;
</code></pre>
<h4 id="14-责任链模式"><a href="#14-责任链模式" class="headerlink" title="14.责任链模式"></a>14.责任链模式</h4><p>责任链模式就是一条链上各司其职，对于传入的请求一次经过链上的每一环进行处理，每一个环处理完毕该环应该做的事情后，显示调用下一环来处理该请求，这样一环套一环就形成了一个责任链。<br>核心：每一个环中提供一个 set 方法来设置下一环，然后在 logMessage 先处理自己的事情后，再显示调用下一环处理。<br>场景：例如日志中，ERROR 级别的日志在完成向终端输入 ERROR 错误信息后，还会保存到文件中，这里就是 ErrorLogger -&gt; FileLogger<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617351753340-97e228fb-f6d8-4fdb-8c43-43bcccc40587.png#align=left&display=inline&height=273&margin=%5Bobject%20Object%5D&name=image.png&originHeight=545&originWidth=854&size=53904&status=done&style=none&width=427" alt="image.png"></p>
<pre><code class="java">public abstract class AbstractLogger &#123;
   public static int INFO = 1;
   public static int DEBUG = 2;
   public static int ERROR = 3;

   protected int level;

   //责任链中的下一个元素
   protected AbstractLogger nextLogger;

   public void setNextLogger(AbstractLogger nextLogger)&#123;
      this.nextLogger = nextLogger;
   &#125;

   public void logMessage(int level, String message)&#123;
      if(this.level &lt;= level)&#123;
         write(message);
      &#125;
      if(nextLogger !=null)&#123;
         nextLogger.logMessage(level, message);
      &#125;
   &#125;

   abstract protected void write(String message);

&#125;

public class ConsoleLogger extends AbstractLogger &#123;

   public ConsoleLogger(int level)&#123;
      this.level = level;
   &#125;

   @Override
   protected void write(String message) &#123;
      System.out.println(&quot;Standard Console::Logger: &quot; + message);
   &#125;
&#125;

public class ErrorLogger extends AbstractLogger &#123;

   public ErrorLogger(int level)&#123;
      this.level = level;
   &#125;

   @Override
   protected void write(String message) &#123;
      System.out.println(&quot;Error Console::Logger: &quot; + message);
   &#125;
&#125;

public class FileLogger extends AbstractLogger &#123;

   public FileLogger(int level)&#123;
      this.level = level;
   &#125;

   @Override
   protected void write(String message) &#123;
      System.out.println(&quot;File::Logger: &quot; + message);
   &#125;
&#125;

public class FileLogger extends AbstractLogger &#123;

   public FileLogger(int level)&#123;
      this.level = level;
   &#125;

   @Override
   protected void write(String message) &#123;
      System.out.println(&quot;File::Logger: &quot; + message);
   &#125;
&#125;
</code></pre>
<h4 id="15-命令模式"><a href="#15-命令模式" class="headerlink" title="15.命令模式"></a>15.命令模式</h4><p>命令模式就是将命令包裹在对象中，然后传递给实现命令者，这过程就涉及到三者：命令发出者（请求）、命令、命令执行者。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617371840721-4bebe15c-629d-4b6e-b8cd-10325f7a7641.png#align=left&display=inline&height=299&margin=%5Bobject%20Object%5D&name=image.png&originHeight=597&originWidth=711&size=53720&status=done&style=none&width=355.5" alt="image.png"></p>
<pre><code class="java">// 请求
public class Stock &#123;

   private String name = &quot;ABC&quot;;
   private int quantity = 10;

   public void buy()&#123;
      System.out.println(&quot;Stock [ Name: &quot;+name+&quot;,
         Quantity: &quot; + quantity +&quot; ] bought&quot;);
   &#125;
   public void sell()&#123;
      System.out.println(&quot;Stock [ Name: &quot;+name+&quot;,
         Quantity: &quot; + quantity +&quot; ] sold&quot;);
   &#125;
&#125;

// 命令1
public class BuyStock implements Order &#123;
   private Stock abcStock;

   public BuyStock(Stock abcStock)&#123;
      this.abcStock = abcStock;
   &#125;

   public void execute() &#123;
      abcStock.buy();
   &#125;
&#125;

// 命令2
public class SellStock implements Order &#123;
   private Stock abcStock;

   public SellStock(Stock abcStock)&#123;
      this.abcStock = abcStock;
   &#125;

   public void execute() &#123;
      abcStock.sell();
   &#125;
&#125;

// 命令执行者
import java.util.ArrayList;
import java.util.List;

public class Broker &#123;
   private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;();

   public void takeOrder(Order order)&#123;
      orderList.add(order);
   &#125;

   public void placeOrders()&#123;
      for (Order order : orderList) &#123;
         order.execute();
      &#125;
      orderList.clear();
   &#125;
&#125;

// 测试
public class CommandPatternDemo &#123;
   public static void main(String[] args) &#123;
      Stock abcStock = new Stock();

      BuyStock buyStockOrder = new BuyStock(abcStock);
      SellStock sellStockOrder = new SellStock(abcStock);

      Broker broker = new Broker();
      broker.takeOrder(buyStockOrder);
      broker.takeOrder(sellStockOrder);

      broker.placeOrders();
   &#125;
&#125;
</code></pre>
<h4 id="16-解释器模式"><a href="#16-解释器模式" class="headerlink" title="16.解释器模式"></a>16.解释器模式</h4><p>通常用在评估语言，因为语言的判断有许多且或的判断，那么就可以利用解释器模式通过将判断进行且或的组合从而判断语言的正确性。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617372843133-bc6f00bd-2664-4c3b-a37e-ffa87131656b.png#align=left&display=inline&height=244&margin=%5Bobject%20Object%5D&name=image.png&originHeight=488&originWidth=536&size=134937&status=done&style=none&width=268" alt="image.png"></p>
<pre><code class="java">// 原子判断
public class TerminalExpression implements Expression &#123;

   private String data;

   public TerminalExpression(String data)&#123;
      this.data = data;
   &#125;

   @Override
   public boolean interpret(String context) &#123;
      if(context.contains(data))&#123;
         return true;
      &#125;
      return false;
   &#125;
&#125;

// 与判断
public class AndExpression implements Expression &#123;

   private Expression expr1 = null;
   private Expression expr2 = null;

   public AndExpression(Expression expr1, Expression expr2) &#123;
      this.expr1 = expr1;
      this.expr2 = expr2;
   &#125;

   @Override
   public boolean interpret(String context) &#123;
      return expr1.interpret(context) &amp;&amp; expr2.interpret(context);
   &#125;
&#125;

// 或判断
public class OrExpression implements Expression &#123;

   private Expression expr1 = null;
   private Expression expr2 = null;

   public OrExpression(Expression expr1, Expression expr2) &#123;
      this.expr1 = expr1;
      this.expr2 = expr2;
   &#125;

   @Override
   public boolean interpret(String context) &#123;
      return expr1.interpret(context) || expr2.interpret(context);
   &#125;
&#125;

//
public class InterpreterPatternDemo &#123;

   //规则：Robert 和 John 是男性
   public static Expression getMaleExpression()&#123;
      Expression robert = new TerminalExpression(&quot;Robert&quot;);
      Expression john = new TerminalExpression(&quot;John&quot;);
      return new OrExpression(robert, john);
   &#125;

   //规则：Julie 是一个已婚的女性
   public static Expression getMarriedWomanExpression()&#123;
      Expression julie = new TerminalExpression(&quot;Julie&quot;);
      Expression married = new TerminalExpression(&quot;Married&quot;);
      return new AndExpression(julie, married);
   &#125;

   public static void main(String[] args) &#123;
      Expression isMale = getMaleExpression();
      Expression isMarriedWoman = getMarriedWomanExpression();

      System.out.println(&quot;John is male? &quot; + isMale.interpret(&quot;John&quot;));
      System.out.println(&quot;Julie is a married women? &quot;
      + isMarriedWoman.interpret(&quot;Married Julie&quot;));
   &#125;
&#125;
</code></pre>
<h4 id="17-迭代器模式"><a href="#17-迭代器模式" class="headerlink" title="17.迭代器模式"></a>17.迭代器模式</h4><p>通过集合类内部封装一个实现了 Iterator 接口的类，通过该内部类来迭代访问集合内部的数据，用户而不需要去关心集合内部遍历的细节，Iterator 对外提供了一个统一的遍历集合的行为模式。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617373706496-cbb9d82c-5eb0-4eae-aa66-cbf1b9bed142.png#align=left&display=inline&height=137&margin=%5Bobject%20Object%5D&name=image.png&originHeight=273&originWidth=560&size=77269&status=done&style=none&width=280" alt="image.png"></p>
<pre><code class="java">public interface Iterator &#123;
   public boolean hasNext();
   public Object next();
&#125;

public interface Container &#123;
   public Iterator getIterator();
&#125;

public class NameRepository implements Container &#123;
   public String[] names = &#123;&quot;Robert&quot; , &quot;John&quot; ,&quot;Julie&quot; , &quot;Lora&quot;&#125;;

   @Override
   public Iterator getIterator() &#123;
      return new NameIterator();
   &#125;

   private class NameIterator implements Iterator &#123;

      int index;

      @Override
      public boolean hasNext() &#123;
         if(index &lt; names.length)&#123;
            return true;
         &#125;
         return false;
      &#125;

      @Override
      public Object next() &#123;
         if(this.hasNext())&#123;
            return names[index++];
         &#125;
         return null;
      &#125;
   &#125;
&#125;
public class NameRepository implements Container &#123;
   public String[] names = &#123;&quot;Robert&quot; , &quot;John&quot; ,&quot;Julie&quot; , &quot;Lora&quot;&#125;;

   @Override
   public Iterator getIterator() &#123;
      return new NameIterator(); // 这里getIterator始终返回的是一个新的对象，所以index总是初始化为默认值0
   &#125;

   private class NameIterator implements Iterator &#123;

      int index;

      @Override
      public boolean hasNext() &#123;
         if(index &lt; names.length)&#123;
            return true;
         &#125;
         return false;
      &#125;

      @Override
      public Object next() &#123;
         if(this.hasNext())&#123;
            return names[index++];
         &#125;
         return null;
      &#125;
   &#125;
&#125;
</code></pre>
<h4 id="18-中介者模式"><a href="#18-中介者模式" class="headerlink" title="18.中介者模式"></a>18.中介者模式</h4><p>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互，该类通常处理不同类之间的通信。<br>也就是每个对象在调用自己的功能时，其实是在调用中介对象提供的功能。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617374054516-fc89f2c0-53d0-4138-816c-596967ec519a.png#align=left&display=inline&height=68&margin=%5Bobject%20Object%5D&name=image.png&originHeight=135&originWidth=560&size=40036&status=done&style=none&width=280" alt="image.png"></p>
<pre><code class="java">import java.util.Date;

public class ChatRoom &#123;
   public static void showMessage(User user, String message)&#123;
      System.out.println(new Date().toString()
         + &quot; [&quot; + user.getName() +&quot;] : &quot; + message);
   &#125;
&#125;

public class User &#123;
   private String name;

   public String getName() &#123;
      return name;
   &#125;

   public void setName(String name) &#123;
      this.name = name;
   &#125;

   public User(String name)&#123;
      this.name  = name;
   &#125;

   public void sendMessage(String message)&#123;
      ChatRoom.showMessage(this,message); // 对象发出消息其实是在利用中介ChatRoom提供的功能
   &#125;
&#125;

public class MediatorPatternDemo &#123;
   public static void main(String[] args) &#123;
      User robert = new User(&quot;Robert&quot;);
      User john = new User(&quot;John&quot;);

      robert.sendMessage(&quot;Hi! John!&quot;);
      john.sendMessage(&quot;Hello! Robert!&quot;);
   &#125;
&#125;
</code></pre>
<h4 id="19-备忘录模式"><a href="#19-备忘录模式" class="headerlink" title="19.备忘录模式"></a>19.备忘录模式</h4><p>备忘录模式就是可以保存对象状态（成员变量）到另一个封装的对象中，然后该对象可以通过保存的存档来恢复自身的成员变量到旧值。<br>故对象内部需要提供一个保存成员变量到另一个对象的方法以及恢复成员变量到指定的存档。<br>这里的 Memento 就是存档，用来保存 Originator 的成员变量，Originator 类提供一个主动保存存档的方法 saveStateToMemento，以及恢复状态到指定存档 getStateFromMemento，存档保存在 CareTaker 中<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617375040102-42e07ae4-a0b6-4768-b1b5-94d2f3fe53d4.png#align=left&display=inline&height=321&margin=%5Bobject%20Object%5D&name=image.png&originHeight=360&originWidth=560&size=82552&status=done&style=none&width=500" alt="image.png"></p>
<pre><code class="java">public class Originator &#123;
   private String state;

   public void setState(String state)&#123;
      this.state = state;
   &#125;

   public String getState()&#123;
      return state;
   &#125;

   // 保存存档，返回是一个新建的存档对象
   public Memento saveStateToMemento()&#123;
      return new Memento(state);
   &#125;

   // 将成员变量恢复至指定的存档
   public void getStateFromMemento(Memento Memento)&#123;
      state = Memento.getState();
   &#125;
&#125;

// 存档，拥有和对象Originator一样的成员变量
public class Memento &#123;
   private String state;

   public Memento(String state)&#123;
      this.state = state;
   &#125;

   public String getState()&#123;
      return state;
   &#125;
&#125;

// 存档保存位置
public class CareTaker &#123;
   private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;();

   public void add(Memento state)&#123;
      mementoList.add(state);
   &#125;

   public Memento get(int index)&#123;
      return mementoList.get(index);
   &#125;
&#125;

public class MementoPatternDemo &#123;
   public static void main(String[] args) &#123;
      Originator originator = new Originator();
      CareTaker careTaker = new CareTaker();
      originator.setState(&quot;State #1&quot;);
      originator.setState(&quot;State #2&quot;);
      careTaker.add(originator.saveStateToMemento()); // 主动保存存档到存档池中
      originator.setState(&quot;State #3&quot;);
      careTaker.add(originator.saveStateToMemento());
      originator.setState(&quot;State #4&quot;);

      System.out.println(&quot;Current State: &quot; + originator.getState());
      originator.getStateFromMemento(careTaker.get(0)); // 对象主动恢复存档
      System.out.println(&quot;First saved State: &quot; + originator.getState());
      originator.getStateFromMemento(careTaker.get(1));
      System.out.println(&quot;Second saved State: &quot; + originator.getState());
   &#125;
&#125;
</code></pre>
<h4 id="20-观察者模式"><a href="#20-观察者模式" class="headerlink" title="20.观察者模式"></a>20.观察者模式</h4><p>当被观察的对象成员变量发生变化时，将会通知其所有的观察者了，为此被观察的对象需要有个成员变量是列表用来存放其观察者们，此外观察者需要获取到被观察对象的成员变量，为此观察者需要添加被观察的对象为成员变量，此外添加被观察的对象为成员变量的同时，还将观察者加入到被观察对象的列表中。<br>缺点：如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617381005353-a66a1f55-dc96-49ef-883f-40b60c2387ef.png#align=left&display=inline&height=345&margin=%5Bobject%20Object%5D&name=image.png&originHeight=386&originWidth=560&size=111372&status=done&style=none&width=500" alt="image.png"></p>
<pre><code class="java">// 被观察的对象有一个成员变量列表来存放观察者，在setState即成员变量发生变化的时候，通知所有的观察者
public class Subject &#123;

   private List&lt;Observer&gt; observers
      = new ArrayList&lt;Observer&gt;();
   private int state;

   public int getState() &#123;
      return state;
   &#125;

   public void setState(int state) &#123;
      this.state = state;
      notifyAllObservers();
   &#125;

   public void attach(Observer observer)&#123;
      observers.add(observer);
   &#125;

   public void notifyAllObservers()&#123;
      for (Observer observer : observers) &#123;
         observer.update();
      &#125;
   &#125;
&#125;

// 观察者的公共抽象类
public abstract class Observer &#123;
   protected Subject subject;
   public abstract void update();
&#125;

// 观察者为了可以获取到被观察者的成员变量，这里需要将被观察者塞入到观察者，当做其成员变量的一部分
public class BinaryObserver extends Observer&#123;

   public BinaryObserver(Subject subject)&#123;
      this.subject = subject;
      this.subject.attach(this);
   &#125;

   @Override
   public void update() &#123;
      System.out.println( &quot;Binary String: &quot;
      + Integer.toBinaryString( subject.getState() ) );
   &#125;
&#125;

public class OctalObserver extends Observer&#123;

   public OctalObserver(Subject subject)&#123;
      this.subject = subject;
      this.subject.attach(this);
   &#125;

   @Override
   public void update() &#123;
     System.out.println( &quot;Octal String: &quot;
     + Integer.toOctalString( subject.getState() ) );
   &#125;
&#125;

public class ObserverPatternDemo &#123;
   public static void main(String[] args) &#123;
      Subject subject = new Subject();

      new HexaObserver(subject);
      new OctalObserver(subject);
      new BinaryObserver(subject);

      System.out.println(&quot;First state change: 15&quot;);
      subject.setState(15);
      System.out.println(&quot;Second state change: 10&quot;);
      subject.setState(10);
   &#125;
&#125;
</code></pre>
<h4 id="21-状态模式"><a href="#21-状态模式" class="headerlink" title="21.状态模式"></a>21.状态模式</h4><p>一个实例对象的行为根据它所处的状态而发生改变，在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。<br>我们将创建一个 State 接口和实现了 State 接口的实体状态类。Context 是一个带有某个状态的类，一般一个对象处于什么状态，是通过 State 中的 doAction 将对象填入，然后对象中还有一个 state 表示当前状态，对象作出的行为实际上是通过 State 中的 doAction 来设置。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617381535763-4bc8c374-f135-4f90-ad44-a851bcd7df48.png#align=left&display=inline&height=346&margin=%5Bobject%20Object%5D&name=image.png&originHeight=387&originWidth=560&size=78650&status=done&style=none&width=500" alt="image.png"></p>
<h4 id="22-空对象模式"><a href="#22-空对象模式" class="headerlink" title="22.空对象模式"></a>22.空对象模式</h4><p>就是根据用户的查询条件来给予产品列表中的某一项，当产品列表中没有符合用户查询条件的，就返回一个空对象提供一个默认的行为。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617382234173-65c514f4-1e39-4628-9989-cd17e31ee5bf.png#align=left&display=inline&height=270&margin=%5Bobject%20Object%5D&name=image.png&originHeight=302&originWidth=560&size=108236&status=done&style=none&width=500" alt="image.png"></p>
<pre><code class="java">public abstract class AbstractCustomer &#123;
   protected String name;
   public abstract boolean isNil();
   public abstract String getName();
&#125;

public class RealCustomer extends AbstractCustomer &#123;

   public RealCustomer(String name) &#123;
      this.name = name;
   &#125;

   @Override
   public String getName() &#123;
      return name;
   &#125;

   @Override
   public boolean isNil() &#123;
      return false;
   &#125;
&#125;

// 空对象，提供默认的行为
public class NullCustomer extends AbstractCustomer &#123;

   @Override
   public String getName() &#123;
      return &quot;Not Available in Customer Database&quot;;
   &#125;

   @Override
   public boolean isNil() &#123;
      return true;
   &#125;
&#125;

// 根据用户查询条件，提供产品
public class CustomerFactory &#123;

   public static final String[] names = &#123;&quot;Rob&quot;, &quot;Joe&quot;, &quot;Julie&quot;&#125;; // 产品列表

   public static AbstractCustomer getCustomer(String name)&#123;
      for (int i = 0; i &lt; names.length; i++) &#123;
         if (names[i].equalsIgnoreCase(name))&#123;
            return new RealCustomer(name);
         &#125;
      &#125;
      return new NullCustomer(); // 查不到符合条件的产品则返回一个默认为空的产品
   &#125;
&#125;

public class NullPatternDemo &#123;
   public static void main(String[] args) &#123;

      AbstractCustomer customer1 = CustomerFactory.getCustomer(&quot;Rob&quot;);
      AbstractCustomer customer2 = CustomerFactory.getCustomer(&quot;Bob&quot;);
      AbstractCustomer customer3 = CustomerFactory.getCustomer(&quot;Julie&quot;);
      AbstractCustomer customer4 = CustomerFactory.getCustomer(&quot;Laura&quot;);

      System.out.println(&quot;Customers&quot;);
      System.out.println(customer1.getName());
      System.out.println(customer2.getName());
      System.out.println(customer3.getName());
      System.out.println(customer4.getName());
   &#125;
&#125;
</code></pre>
<h4 id="23-策略模式"><a href="#23-策略模式" class="headerlink" title="23.策略模式"></a>23.策略模式</h4><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。也就是说类的行为根据其采用的策略而发生改变<br>代码实现：因为有很多策略，为此我们抽象处一个策略接口定义策略的行为，类的行为中有一个成员变量是策略接口的实现类，其行为实际是调用策略的行为来实现。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617382549181-8961496c-381c-4cef-b571-54f984eba9a0.png#align=left&display=inline&height=287&margin=%5Bobject%20Object%5D&name=image.png&originHeight=321&originWidth=560&size=95853&status=done&style=none&width=500" alt="image.png"></p>
<pre><code class="java">// 策略接口
public interface Strategy &#123;
   // 策略的执行方式
   public int doOperation(int num1, int num2);
&#125;

// 策略1
public class OperationAdd implements Strategy&#123;
   @Override
   public int doOperation(int num1, int num2) &#123;
      return num1 + num2;
   &#125;
&#125;

// 策略2
public class OperationSubtract implements Strategy&#123;
   @Override
   public int doOperation(int num1, int num2) &#123;
      return num1 - num2;
   &#125;
&#125;

// 对象的成员中有一个策略成员变量
public class Context &#123;
   private Strategy strategy;

   public Context(Strategy strategy)&#123;
      this.strategy = strategy;
   &#125;

   // 其行为实际由策略所执行
   public int executeStrategy(int num1, int num2)&#123;
      return strategy.doOperation(num1, num2);
   &#125;
&#125;

public class StrategyPatternDemo &#123;
   public static void main(String[] args) &#123;
      Context context = new Context(new OperationAdd());
      System.out.println(&quot;10 + 5 = &quot; + context.executeStrategy(10, 5));

      context = new Context(new OperationSubtract());
      System.out.println(&quot;10 - 5 = &quot; + context.executeStrategy(10, 5));

      context = new Context(new OperationMultiply());
      System.out.println(&quot;10 * 5 = &quot; + context.executeStrategy(10, 5));
   &#125;
&#125;
</code></pre>
<h4 id="24-模板模式"><a href="#24-模板模式" class="headerlink" title="24.模板模式"></a>24.模板模式</h4><p>就是一个抽象类已经将行为执行步骤确定下来，你需要做的就是实现该抽象类中这每一个步骤，然后就可以调用行为实现逻辑了。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617382849113-48d4a563-24cd-4190-80a3-f99cb6797c7f.png#align=left&display=inline&height=332&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=560&size=84522&status=done&style=none&width=500" alt="image.png"></p>
<pre><code class="java">public abstract class Game &#123;
   abstract void initialize();
   abstract void startPlay();
   abstract void endPlay();

   //模板，其行为执行步骤已经确定下来，final就不能被子类覆写该执行步骤
   public final void play()&#123;

      //初始化游戏
      initialize();

      //开始游戏
      startPlay();

      //结束游戏
      endPlay();
   &#125;
&#125;

// 子类只需实现相应的每个步骤的方法，方法之间调用顺序以及逻辑由抽象类内部已经确定
public class Cricket extends Game &#123;

   @Override
   void endPlay() &#123;
      System.out.println(&quot;Cricket Game Finished!&quot;);
   &#125;

   @Override
   void initialize() &#123;
      System.out.println(&quot;Cricket Game Initialized! Start playing.&quot;);
   &#125;

   @Override
   void startPlay() &#123;
      System.out.println(&quot;Cricket Game Started. Enjoy the game!&quot;);
   &#125;
&#125;

public class Cricket extends Game &#123;

   @Override
   void endPlay() &#123;
      System.out.println(&quot;Cricket Game Finished!&quot;);
   &#125;

   @Override
   void initialize() &#123;
      System.out.println(&quot;Cricket Game Initialized! Start playing.&quot;);
   &#125;

   @Override
   void startPlay() &#123;
      System.out.println(&quot;Cricket Game Started. Enjoy the game!&quot;);
   &#125;
&#125;

public class TemplatePatternDemo &#123;
   public static void main(String[] args) &#123;

      Game game = new Cricket();
      game.play();
      System.out.println();
      game = new Football();
      game.play();
   &#125;
&#125;
</code></pre>
<h4 id="25-访问者模式"><a href="#25-访问者模式" class="headerlink" title="25.访问者模式"></a>25.访问者模式</h4><p>访问者模式就是可以在一个类中提供一个接口来放入访问者，其每一个组件都可以接受 accept 外来的访问者，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2648023/1617383266169-77ca8b82-7b2e-485a-94c0-7982f7036148.png#align=left&display=inline&height=369&margin=%5Bobject%20Object%5D&name=image.png&originHeight=413&originWidth=560&size=92050&status=done&style=none&width=500" alt="image.png"></p>
<pre><code class="java">public interface ComputerPart &#123;
   public void accept(ComputerPartVisitor computerPartVisitor);
&#125;

// 每个组件都可以接受访问者，访问者可以访问其内部状态
public class Monitor  implements ComputerPart &#123;

   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) &#123;
      computerPartVisitor.visit(this); //传递this，访问者就可以访问组件内部状态
   &#125;
&#125;

public class Keyboard  implements ComputerPart &#123;

   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) &#123;
      computerPartVisitor.visit(this);
   &#125;
&#125;

public class Keyboard  implements ComputerPart &#123;

   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) &#123;
      computerPartVisitor.visit(this);
   &#125;
&#125;

public interface ComputerPartVisitor &#123;
   public void visit(Computer computer);
   public void visit(Mouse mouse);
   public void visit(Keyboard keyboard);
   public void visit(Monitor monitor);
&#125;

public class ComputerPartDisplayVisitor implements ComputerPartVisitor &#123;

   @Override
   public void visit(Computer computer) &#123;
      System.out.println(&quot;Displaying Computer.&quot;);
   &#125;

   @Override
   public void visit(Mouse mouse) &#123;
      System.out.println(&quot;Displaying Mouse.&quot;);
   &#125;

   @Override
   public void visit(Keyboard keyboard) &#123;
      System.out.println(&quot;Displaying Keyboard.&quot;);
   &#125;

   @Override
   public void visit(Monitor monitor) &#123;
      System.out.println(&quot;Displaying Monitor.&quot;);
   &#125;
&#125;

public class VisitorPatternDemo &#123;
   public static void main(String[] args) &#123;

      ComputerPart computer = new Computer();
      computer.accept(new ComputerPartDisplayVisitor());
   &#125;
&#125;
</code></pre>

        </div>

    </div>

    

    

    

    
  <div class="article-copyright hairline">
    <p>
      本作品采用  <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议 (CC BY-NC-ND 4.0)</a> 进行许可。
    </p>
  </div>
  

    

    
<nav class="article-nav">
  
    <a href="/2021/Spring/yuque/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          自定义数据校验注解
        
      </div>
    </a>
  
  
    <a href="/2021/uncategorized/yuque/%E5%86%B7%E5%90%AF%E5%8A%A8%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%AE%AD%E7%BB%83/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">冷启动如何快速训练</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=设计模式 - 一止长渊的博客&url=https://yizhichangyuan.github.io/2021/%E4%BF%AE%E8%A1%8C/yuque/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
            <box-icon type='logo' name='twitter'></box-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=设计模式 - 一止长渊的博客&u=https://yizhichangyuan.github.io/2021/%E4%BF%AE%E8%A1%8C/yuque/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
            <box-icon name='facebook-square' type='logo' ></box-icon>
        </a>
        <!-- <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=设计模式 - 一止长渊的博客&url=https://yizhichangyuan.github.io/2021/%E4%BF%AE%E8%A1%8C/yuque/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a> -->
    </section>

</article>








<section class="comments">
    <div id="gitalk-container"></div>
</section>









<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</div>
                </section>
            </section>

            
            <aside class="sidebar sidebar-search-fix">
                

    <div class="search">
    <div class="has-icon-right">
        <input type="text" class="form-input" id="search" placeholder="SEARCH" autocomplete="off">
        <div class="form-icon">
            <box-icon name='search' color="#3c4859"></box-icon>
        </div>
    </div>
    <div class="search-result" id="search-ps"></div>
</div>


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E4%B8%9C%E6%88%98%E4%BA%89%E5%8F%B2/">中东战争史</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BF%AE%E8%A1%8C/">修行</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Elasticsearch/" rel="tag">Elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kaptcha/" rel="tag">Kaptcha</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MYSQL%E9%9B%86%E7%BE%A4/" rel="tag">MYSQL集群</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nacos/" rel="tag">Nacos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zxing/" rel="tag">Zxing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2/" rel="tag">历史</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/" rel="tag">数据校验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%AD%E9%93%BE/" rel="tag">短链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/" rel="tag">缓存一致性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2021/uncategorized/yuque/ThreadPoolExecutor/">ThreadPoolExecutor</a>
          </li>
        
          <li>
            <a href="/2021/uncategorized/yuque/%E4%B8%AD%E6%96%AD/">中断</a>
          </li>
        
          <li>
            <a href="/2021/uncategorized/yuque/ConcurrentHashMap%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/">ConcurrentHashMap原理初探</a>
          </li>
        
          <li>
            <a href="/2021/uncategorized/yuque/%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%90%8C%E6%97%B6%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%90%8C%E7%B1%BB%E5%9E%8BBean%E5%AD%98%E5%9C%A8/">容器中同时有两个同类型Bean存在</a>
          </li>
        
          <li>
            <a href="/2021/uncategorized/yuque/%E7%A7%92%E6%9D%80/">秒杀</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            一止长渊的博客 &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>


<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>





<script src="/dist/build.js?1646451311888.js"></script>


<script src="/dist/custom.js?1646451311888.js"></script>



<!-- 百度链接提交 -->
<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>



<!-- Google Analytics-->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXX-X"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-XXXXX-X');
</script>









</body>

</html>